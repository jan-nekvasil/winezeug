#!/bin/sh
# LGPL
# Copyright 2010 Dan Kegel
# Experimental cleanup of wisotool
#
#--------------------------------------------------------------------
# See http://code.google.com/p/winezeug/wiki/ConvergedFrontends
#
# This script, and the verbs it invokes, should follow these Coding standards:
#
# Portability:
# - Portability matters, as this script is run on many operating systems
# - No bash, zsh, or csh extensions
# - Prefer classic sh idioms
# - If there is no universally available program for a needed function,
#   support the two most frequently available programs.
#   e.g. fall back to wget if curl is not available; likewise, support
#   both sha1sum and openssl.
# - When using unix commands like cp, put options before filenames
#   so it will work on systems like BSD and MacOSX
#
# Formatting:
# - Your terminal and editor must be configured for utf-8
#   If you do not see an o with two dots over it here [ö], stop!
# - Do not use tabs in this file or any verbs.
# - Indent 4 spaces.
# - Curlies and 'then' at beginning of line.
# - cases aligned with 'case' and 'esac'
# - Try to keep line length below 80 (makes printing easier)
#
# Commenting:
# - Comments should explain intent in English
# - Keep functions short and well named to reduce need for comments
#
# Naming:
# Public things defined by this script, for use by verbs:
# - Variables have uppercase names starting with W_
# - Functions have lowercase names starting with w_
# Private things internal to this script, not for use by verbs: 
# - Local variables have lowercase names starting with uppercase _W_
# - Global variables have uppercase names starting with WISOTOOL_
# - Functions have lowercase names starting with wisotool_
#
# Internationalization / localization:
# - Important or frequently used message should be internationalized
#   so translations can be easily added.  For example:
#     case $LANG in
#     de*) echo "Das ist die deutsche Meldung" ;;
#     *)   echo "This is the English message" ;;
#     esac
#
#--------------------------------------------------------------------

# Name of this version of wisotool (YYYYMMDD)
WISOTOOL_VERSION=20101124

#---- Public Functions ----

# Display warning message
w_warn()
{
    echo "------------------------------------------------------"
    echo "$@"
    echo "------------------------------------------------------"

    # For some reason, nulls were showing up in $@?!, causing truncated output in zenity
    msg="`echo $@ | tr '\000' ' '`"
    case $WISOTOOL_GUI in
    zenity) zenity --error --title=Wisotool --text="$msg" --no-wrap;;
    kdialog) kdialog --title Wisotool --error "$msg" ;;
    none) ;;
    esac
}

# Display fatal error message
w_die()
{
    w_warn "$@"

    exit 1
}

if test "`which perl`" = ""
then
    w_die "please install perl before running this script"
fi

# Execute with error checking
w_try()
{
    # "VAR=foo try cmd" fails to put VAR in the environment
    # with some versions of bash if try is a shell function?!
    # Adding this explicit export works around it.
    export WINEDLLOVERRIDES
    echo Executing "$@"
    # Mark executable - needed if running on windows vista
    case "$1" in
    *.exe) chmod +x "$1" || true
      cmd /c "$@"
      ;;
    *)
      "$@"
      ;;
    esac
    status=$?
    if test $status -ne 0
    then
        w_die "Note: command '$@' returned status $status.  Aborting."
    fi
}

w_try_regedit()
{
    # on windows, doesn't work without cmd /c
    case "$OS" in
    "Windows_NT") cmdc="cmd /c";;
    *) unset cmdc
    esac

    w_try wisotool_early_wine $cmdc regedit $W_UNATTENDED_SLASH_S "$@"
}

w_try_regsvr()
{
    w_try $WINE regsvr32 $W_UNATTENDED_SLASH_S $@
}

w_try_cabextract()
{
    # Not always installed, but shouldn't be fatal unless it's being used
    _W_CABEXTRACT="`which cabextract 2>/dev/null`" 
    if test ! -x "$_W_CABEXTRACT"
    then
        w_die "Cannot find cabextract.  Please install it (e.g. 'sudo apt-get install cabextract' or 'sudo yum install cabextract')."
    fi
    
    w_try $_W_CABEXTRACT "$@"

    unset _W_CABEXTRACT
}

w_try_winetricks()
{
    w_try "$WISOTOOL_WINETRICKS" $W_UNATTENDED_DASH_Q $*
}

w_read_key()
{
    case "$W_OPT_UNATTENDED" in
    0) W_KEY=dummy_to_make_autohotkey_happy ; return 0 ;;
    esac

    _W_keyfile="$W_CACHE/$W_PACKAGE/key.txt"
    if ! test -f "$_W_keyfile"
    then
        # read key from user
        case $LANG in
        da*) _W_keymsg="Angiv venligst registrerings-nøglen for pakken '$_PACKAGE'"
            _W_nokeymsg="Ingen nøgle angivet"
            ;;
        de*) _W_keymsg="Bitte einen Key für Pakete '$W_PACKAGE' eingeben"
            _W_nokeymsg="Keinen Key eingegeben?"
            ;;
        *)  _W_keymsg="Please enter the key for app '$W_PACKAGE'"
            _W_nokeymsg="No key given"
            ;;
        esac
        case $WISOTOOL_GUI in
        *zenity) W_KEY=`zenity --entry --text "$_W_keymsg"` ;;
        *kdialog) W_KEY=`kdialog --inputbox "$_W_keymsg"` ;; 
        *xmessage) w_die "sorry, can't read key from gui with xmessage" ;;
        none) echo -n "$_W_keymsg": ; read W_KEY ;;
        esac
        if test "$W_KEY" = ""
        then
            w_die "$_W_nokeymsg"
        fi
        echo "$W_KEY" > "$_W_keyfile"
    fi
    W_KEY=`cat "$_W_keyfile" | tr -d -`
    unset _W_keyfile _W_keymsg _W_nokeymsg
}

# Convert a Unix path to a Windows path
# Usage is lowest common denominator of cygpath/winepath
# so -u to convert to unix, and -w to convert to windows
w_pathconv()
{
    case "$OS" in
     "Windows_NT")
        cygpath "$@"
        ;;
     *)
        wisotool_early_wine winepath "$@"
        ;;
    esac
}

# verify an sha1sum
w_verify_sha1sum()
{
    _W_vs_wantsum=$1
    _W_vs_file=$2

    _W_vs_gotsum=`$WISOTOOL_SHA1SUM < $_W_file | sed 's/ .*//'`
    if [ "$_W_vs_gotsum"x != "$_W_vs_wantsum"x ]
    then
       w_die "sha1sum mismatch!  Rename $_W_vs_file and try again."
    fi
    unset _W_vs_wantsum _W_vs_file _W_vs_gotsum
}

# Download a file
# Usage: w_download packagename url [sha1sum [filename [cookie jar]]]
# Caches downloads in wisotoolcache/$packagename
w_download()
{
    _W_packagename="$1"
    _W_url="$2"
    _W_sum="$3"
    _W_file="$4"
    _W_cookiejar="$5"

    case $_W_packagename in
    .) w_die "bug: please do not download packages to top of cache" ;;
    esac

    if [ "$_W_file"x = ""x ]
    then
        _W_file=`basename "$_W_url"`
    fi
    _W_cache="$W_CACHE/$_W_packagename"
    mkdir -p "$_W_cache"
    if test ! -s "$_W_cache/$_W_file" && test -f "$_W_cache/$_W_file"
    then
        # zero size - bad download?
        rm "$_W_cache/$_W_file"
    fi
    if test "$nosizecheck" != "" || test ! -f "$_W_cache/$_W_file" || test "$WISOTOOL_CONTINUE_DOWNLOAD"
    then
        cd "$_W_cache"
        # Mac folks tend to have curl rather than wget
        # On Mac, 'which' doesn't return good exit status
        # Need to jam in --header "Accept-Encoding: gzip,deflate" else
        # redhat.com decompresses liberation-fonts.tar.gz!
        echo Downloading $_W_url
        if [ -x "`which wget 2>/dev/null`" ]
        then
           # Use -nd to insulate ourselves from people who set -x in WGETRC
           # [*] --retry-connrefused works around the broken sf.net mirroring
           # system when downloading corefonts
           # [*] --read-timeout is useful on the adobe server that doesn't
           # close the connection unless you tell it to (control-C or closing
           # the socket)
           # Disable retries for gog.com (which requires higher level retries)
           wget -O "$_W_file" -nd -c --read-timeout=300 --tries=1 --retry-connrefused --header "Accept-Encoding: gzip,deflate" ${_W_cookiejar:+--load-cookies "$_W_cookiejar"} "$_W_url"
        else
           # curl doesn't get filename from the location given by the server!
           # fortunately, we know it
           curl -L -o "$_W_file" -C - --header "Accept-Encoding: gzip,deflate" ${_W_cookiejar:+--cookie "$_W_cookiejar"} "$_W_url"
        fi
        if test $? != 0
        then
            test -f "$_W_file" && rm "$_W_file"
            w_die "Downloading $_W_url failed"
        fi
        # Need to decompress .exe's that are compressed, else cygwin fails
        # Only affects cygwin, so don't barf if 'file' not installed
        _W_filetype=`which file 2>/dev/null`
        case $_W_filetype-$_W_file in
        /*-*.exe)
            case `file $_W_file` in
            *gzip*) mv $_W_file $_W_file.gz; gunzip < $_W_file.gz > $_W_file;;
            esac
        esac

        # On cygwin, .exe's must be marked +x
        case $_W_file in
        *.exe) chmod +x $_W_file ;;
        esac

        if [ "$_W_sum"x != ""x ]
        then
            w_verify_sha1sum $_W_sum "$_W_cache/$_W_file"
        fi
    fi
}

w_download_manual()
{
    _W_packagename="$1"
    _W_url="$2"
    _W_file="$3"
    _W_sha1sum="$4"

    case $LANG in
    da*) _W_dlmsg="Hent venligst filen $_W_file fra $_W_url og placér den i $W_CACHE/$_W_packagename, kør derefter dette skript.";;
    de*) _W_dlmsg="Bitte laden Sie $_W_file von $_W_url runter, stellen Sie's in $W_CACHE/$_W_packagename, dann wiederholen Sie diesen Kommando.";;
    *) _W_dlmsg="Please download $_W_file from $_W_url, place it in $W_CACHE/$_W_packagename, then re-run this script.";;
    esac

    if ! test -f "$W_CACHE/$_W_packagename/$_W_file"
    then
        mkdir -p "$W_CACHE/$_W_packagename"
        xdg-open "$_W_url"
        sleep 3   # give some time for browser to open
        w_die "$_W_dlmsg"
        # FIXME: wait in loop until file is finished?
    fi
    # FIXME: verify $sha1sum of $file
    unset _W_url _W_file _W_sha1sum _W_dlmsg
}

# Usage: w_mount "volume name"
# FIXME: should take mount option 'unhide' for poorly mastered discs
w_mount()
{
    WISOTOOL_IMG="$W_CACHE/$W_PACKAGE/$1.iso"
    mkdir -p "$W_CACHE/$W_PACKAGE"

    if test -f "$WISOTOOL_IMG"
    then
        wisotool_mount_cached_iso "$1" 
    else
        case "$WISOTOOL_OPT_KEEPISOS" in
        0)
            wisotool_mount_real_volume "$1"
            ;;
        1)
            wisotool_cache_iso "$1" 
            wisotool_mount_cached_iso "$1" 
            ;;
        esac
    fi
}

w_umount()
{
    if test "$WINE" = ""
    then
        w_die Windows not yet supported
    else
        echo "Running $WISOTOOL_SUDO umount $W_ISO_MOUNT_ROOT"
        case "$WISOTOOL_SUDO" in
        gksudo)
          # -l lazy unmount in case executable still running
          $WISOTOOL_SUDO "umount -l $W_ISO_MOUNT_ROOT"
          w_try $WISOTOOL_SUDO "rm -rf $W_ISO_MOUNT_ROOT"
          ;;
        *)
          $WISOTOOL_SUDO umount -l $W_ISO_MOUNT_ROOT
          w_try $WISOTOOL_SUDO rm -rf $W_ISO_MOUNT_ROOT
          ;;
        esac
        rm -f "$WINEPREFIX"/dosdevices/${W_ISO_MOUNT_LETTER}:
        rm -f "$WINEPREFIX"/dosdevices/${W_ISO_MOUNT_LETTER}::
    fi
}

w_ahk_do()
{
    w_try w_call autohotkey
    _W_CR=`printf \\\\r`
    echo "$@" | sed "s/\$/$CR/" > "$W_TMP"/tmp.ahk
    $WINE "$W_PROGRAMS_X86_UNIX/AutoHotkey/AutoHotkey.exe" "$W_TMP_WIN"\\tmp.ahk
    unset _W_CR
}

# Function to protect wine-specific sections of code.
# Outputs a message to console explaining what's being skipped.
# Usage:
#   if w_skip_windows name-of-operation
#   then
#      return
#   fi
#   ... do something that doesn't make sense on windows ...

w_skip_windows()
{
    case "$OS" in
    "Windows_NT")
      echo "Skipping operation '$1' on Windows"
      return 0
      ;;
    esac
    return 1
}

w_override_dlls()
{
    w_skip_windows override && return

    _W_mode=$1
    if [ $_W_mode = "disabled" ]
    then
        _W_mode=""
    fi
    shift
    echo Using $_W_mode override for following DLLs: $@
    cat > "$W_TMP"/override-dll.reg <<_EOF_
REGEDIT4

[HKEY_CURRENT_USER\Software\Wine\DllOverrides]
_EOF_
    while test "$1" != ""
    do
        case "$1" in
        comctl32)
           rm -rf "$W_WINDIR_UNIX"/winsxs/manifests/x86_microsoft.windows.common-controls_6595b64144ccf1df_6.0.2600.2982_none_deadbeef.manifest
           ;;
        esac

        # Note: if you want to override even DLLs loaded with an absolute path,
        # you need to add an asterisk:
        echo "\"*$1\"=\"$_W_mode\"" >> "$W_TMP"/override-dll.reg
        #echo "\"$1\"=\"$_W_mode\"" >> "$W_TMP"/override-dll.reg

        shift
    done

    w_try_regedit "$W_TMP_WIN"\\override-dll.reg
    cat "$W_TMP"/override-dll.reg

    unset _W_mode
}

# Usage: workaround_wine_bug bugnumber [good-wineversion-shell-pattern]
# False (nonzero status) on Windows.
# True (zero status) on Wine unless good-wineversion-shell-pattern is set
# and matches the current wine version.
# For debugging: if you want to skip a bug's workaround, put the bug number in the
# environment variable WISOTOOL_BLACKLIST to disable it.
w_workaround_wine_bug()
{
    if test "$WINE" = ""
    then
        echo No need to work around wine bug $1 on windows
        return 1
    fi
    # FIXME: accept wine version number as $2, only apply if before that
    case $1 in
    "$WISOTOOL_BLACKLIST")
        echo wine bug $1 workaround blacklisted, skipping
        return 1
        ;;
    esac
    case $LANG in
    da*) w_warn "Arbejder uden om wine-fejl $1" ;;
    de*) w_warn "Wine-Fehler $1 wird umgegangen" ;;
    *)   w_warn "Working around wine bug $1" ;;
    esac
    return 0
}

# Function for verbs to register themselves so they show up in the menu.
# Example:
# w_metadata  wog games \
#   title="World of Goo Demo" \
#   pub="2D Boy" \
#   year="2008" \
#   media="download" \
#   file1="WorldOfGooDemo.1.0.exe"

w_metadata()
{
    if test "$installed_exe1" || test "$installed_file1"
    then
        w_die "bug: stray metadata tags set: somebody forgot a backslash in a w_metadata somewhere.  Run with sh -x to see where."
    fi

    file="$WISOTOOL_METADATA/$2/$1.vars"
    shift
    shift
    # FIXME: fall back to posix shell string manipulation if perl not present?
    perl -e 'for (@ARGV) { if (/(\w*)=(.*)/) { print "$1=\"$2\"\n"; } else { die "bad parameter $_" } }' "$@" > "$file"
}

# Function for verbs to register their main executable.
# Example:
#   w_declare_exe "$W_PROGRAMS_X86_WIN\\WorldOfGooDemo" WorldOfGoo.exe
w_declare_exe()
{
    _W_dir="$1"
    _W_exe="$2"
    cat > "$W_DRIVE_C/run-$W_PACKAGE.bat" <<__EOF__
${W_PROGRAMS_DRIVE}:
cd "$_W_dir"
$_W_exe
__EOF__
    unset _W_dir _W_exe
}

# Call a verb, don't let it affect environment
# Supports just one argument at the moment
# Hope that subshell passes through exit status
# If you don't want to check exit status, use w_try w_call
w_call()
{
    (
        . "$WISOTOOL_METADATA"/*/$1.vars

        # Don't install if already installed
        unset _W_file
        if test "$installed_exe1" 
        then
            _W_file="$installed_exe1"
        elif test "$installed_file1"
        then
            _W_file="$installed_file1"
        fi
        if test "$_W_file" 
        then
            _W_file_unix="`w_pathconv -u "$_W_file" | tr -d '\015' `"
            if test -f "$_W_file_unix"
            then
                echo "$1 already installed, skipping"
                return
            fi
        fi
        load_$1 $2
    )
}

w_register_font()
{
    file=$1
    shift
    font=$1
    # Kludge: use _r to avoid \r expansion in w_try
    cat > "$W_TMP"/_register-font.reg <<_EOF_
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Fonts]
"$font"="$file"
_EOF_
    # too verbose
    w_try_regedit "$W_TMP_WIN"\\_register-font.reg
}

w_register_font_substitution()
{
    _W_alias=$1
    shift
    _W_font=$1
    # Kludge: use _r to avoid \r expansion in w_try
    cat > "$W_TMP"/_register-font-sub.reg <<_EOF_
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]
"$_W_alias"="$_W_font"
_EOF_
    w_try_regedit "$W_TMP_WIN"\\_register-font-sub.reg
    unset _W_alias _W_font
}

#---- Private Functions ----

wisotool_print_version() {
    echo "$WISOTOOL_VERSION"
}

# Run a windows command without triggering wine's mshtml's gecko install dialog
wisotool_early_wine()
{
    WINEDEBUG=-all WINEDLLOVERRIDES=mshtml= $WINE "$@"
}

wisotool_detect_gui()
{
    if test -x "`which zenity 2>/dev/null`"
    then
        WISOTOOL_GUI=zenity
    elif test -x "`which kdialog 2>/dev/null`"
    then
        echo "Zenity not found!  Using kdialog as poor substitute."
        WISOTOOL_GUI=kdialog
    else
        echo "Please install zenity if you want a graphical interface."
        exit 1
    fi
}

# Detect which sudo to use
wisotool_detect_sudo()
{
    WISOTOOL_SUDO=sudo
    if test "$WISOTOOL_GUI" = "none"
    then
        return
    fi
    if test x"$DISPLAY" != x""
    then
        if test -x "`which gksudo 2>/dev/null`"
        then
            WISOTOOL_SUDO=gksudo
        elif test -x "`which kdesudo 2>/dev/null`"
        then
            WISOTOOL_SUDO=kdesudo
        fi
    fi
}

# Display main menu, get which submenu the user wants
wisotool_mainmenu()
{
    case $LANG in
    da*) _W_msg_title='Vælg en pakke-kategori'
         _W_msg_body='Hvad ønsker du at gøre?'
         _W_msg_run='Run an already-installed Windows app'
         _W_msg_uninstall='Uninstall a Windows app'
         _W_msg_apps='Installér et program'
         _W_msg_benchmarks='Install a Windows benchmark'
         _W_msg_dlls="Install a Windows DLL"
         _W_msg_fonts='Install a font'
         _W_msg_games='Installér et spil'
         _W_msg_steam='Install a Steam game with Wine'
         ;;
    de*) _W_msg_title='Pakettyp auswählen'
         _W_msg_body='Was möchten Sie tun?'
         _W_msg_run='Run an already-installed Windows app'
         _W_msg_uninstall='Windows-Programm löschen'
         _W_msg_apps='Windows-Programm installieren'
         _W_msg_benchmarks='Windows-Benchmark installieren'
         _W_msg_dlls="Windows-DLL installieren"
         _W_msg_fonts='Schriftart installieren'
         _W_msg_games='Windows-Spiel installieren'
         _W_msg_steam='Steam-Spiel installieren'
         ;;
    *)   _W_msg_title='Select a package category'
         _W_msg_body='What would you like to do?'
         _W_msg_run='Run an already-installed Windows app'
         _W_msg_uninstall='Uninstall a Windows app'
         _W_msg_apps='Install a Windows program'
         _W_msg_benchmarks='Install a Windows benchmark'
         _W_msg_dlls="Install a Windows DLL"
         _W_msg_fonts='Install a font'
         _W_msg_games='Install a Windows game'
         _W_msg_steam='Install a Steam game'
         ;;
    esac

    # FIXME: add line for Steam below once we have steam game verbs
    # FIXME: don't show uninstall option when $WISOTOOL_OPT_SHAREDPREFIX is 1

    case $WISOTOOL_GUI in
    zenity)
        zenity \
            --title "$_W_msg_title" \
            --text "$_W_msg_body" \
            --list \
            --radiolist \
            --column '' \
            --column '' \
            --column '' \
            --height 500 \
            --width 800 \
            --hide-column 2 \
            FALSE dlls       "$_W_msg_dlls" \
            FALSE fonts      "$_W_msg_fonts" \
            FALSE games      "$_W_msg_games" \
            FALSE benchmarks "$_W_msg_benchmarks" \
            FALSE apps       "$_W_msg_apps" \
            FALSE run        "$_W_msg_run" \
            FALSE uninstall  "$_W_msg_uninstall" \
         | tr '|' ' '
        ;;

    kdialog)
        kdialog --geometry 600x400+100+100 \
                --title "$_W_msg_title" \
                --separate-output \
                --radiolist \
                "$_W_msg_body"\
                dlls       "$_W_msg_dlls" off \
                fonts      "$_W_msg_fonts" off \
                games      "$_W_msg_games" off \
                benchmarks "$_W_msg_benchmarks" off \
                apps       "$_W_msg_apps" off \
                run        "$_W_msg_run" off \
                uninstall  "$_W_msg_uninstall" off \

        ;;
    esac
    unset _W_msg_body _W_msg_title _W_msg_apps _W_msg_benchmarks _W_msg_dlls _W_msg_games _W_msg_steam _W_msg_run _W_msg_uninstall
}

# Display the menu of installed apps, output list of selected apps
wisotool_installed_menu()
{
    case $WISOTOOL_CURMENU in
    run)
        case $LANG in
        de*) _W_msg_title='Pakete auswählen'
             _W_msg_body='Welches Programm möchten Sie starten?'
             ;;
        *)   _W_msg_title='Select a program to run'
             _W_msg_body='Which program would you like to run?'
             ;;
        esac
        ;;
    uninstall)
        case $LANG in
        de*) _W_msg_title='Pakete auswählen'
             _W_msg_body='Welches Programm möchten Sie löschen?'
             ;;
        *)   _W_msg_title='Select a program to delete'
             _W_msg_body='Which program would you like to uninstall?'
             ;;
        esac
        ;;
    esac

    case $WISOTOOL_GUI in
    zenity)
        case $LANG in
        da*) echo -n "zenity \
                --title '$_W_msg_title' \
                --text '$_W_msg_body' \
                --list \
                --checklist \
                --column '' \
                --column Pakke \
                --column Navn \
                --column Udgiver \
                --column År \
                --column Medie \
                --height 500 \
                --width 800 \
                " 
             ;;
       de*) echo -n "zenity \
                --title '$_W_msg_title' \
                --text '$_W_msg_body' \
                --list \
                --checklist \
                --column '' \
                --column Paket \
                --column Name \
                --column Herausgeber \
                --column Jahr \
                --column Media \
                --height 500 \
                --width 800 \
                " 
             ;;
        *) echo -n "zenity \
                --title '$_W_msg_title' \
                --text '$_W_msg_body' \
                --list \
                --checklist \
                --column '' \
                --column Package \
                --column Title \
                --column Publisher \
                --column Year \
                --column Media \
                --height 500 \
                --width 800 \
                " 
             ;;
        esac > "$WISOTOOL_WORKDIR"/zenity.sh

        for verb in `wisotool_list_installed`
        do
            metadatafile="`echo "$WISOTOOL_METADATA"/*/$verb.vars`"
            if ! test -f "$metadatafile"
            then
                continue
            fi
            (
            title='?'
            author='?'
            . $metadatafile
            echo -n " " FALSE \
                    $verb \
                    "\"$title\"" \
                    "\"$publisher\"" \
                    "\"$year\"" \
                    "\"$media\""
            )
        done >> $WISOTOOL_WORKDIR/zenity.sh

        sh "$WISOTOOL_WORKDIR"/zenity.sh | tr '|' ' '
        ;;

    kdialog)
        (
        echo -n "kdialog --geometry 600x400+100+100 --title '$_W_msg_title' --separate-output --checklist '$_W_msg_body' "
        wisotool_list_installed | sed 's/\(.*\)/\1 \1 off/' | tr '\012' ' '
        ) > "$WISOTOOL_WORKDIR"/kdialog.sh
        sh "$WISOTOOL_WORKDIR"/kdialog.sh
        ;;
    esac

    unset _W_msg_body _W_msg_title _W_msg_apps _W_msg_games
}

# Display the current menu, output list of verbs to execute to stdout
wisotool_showmenu()
{
    case $LANG in
    da*) _W_msg_title='Vælg en pakke'
         _W_msg_body='Vilken pakke vil du installere?'
         ;;
    de*) _W_msg_title='Pakete auswählen'
         _W_msg_body='Welche Pakete möchten Sie installieren?'
         ;;
    *)   _W_msg_title='Select a package to install'
         _W_msg_body='Which package(s) would you like to install?'
         ;;
    esac

    case $WISOTOOL_GUI in
    zenity)
        case $LANG in
        da*) echo -n "zenity \
                --title '$_W_msg_title' \
                --text '$_W_msg_body' \
                --list \
                --checklist \
                --column '' \
                --column Pakke \
                --column Navn \
                --column Udgiver \
                --column År \
                --column Medie \
                --height 500 \
                --width 800 \
                " 
             ;;
       de*) echo -n "zenity \
                --title '$_W_msg_title' \
                --text '$_W_msg_body' \
                --list \
                --checklist \
                --column '' \
                --column Paket \
                --column Name \
                --column Herausgeber \
                --column Jahr \
                --column Media \
                --height 500 \
                --width 800 \
                " 
             ;;
        *) echo -n "zenity \
                --title '$_W_msg_title' \
                --text '$_W_msg_body' \
                --list \
                --checklist \
                --column '' \
                --column Package \
                --column Title \
                --column Publisher \
                --column Year \
                --column Media \
                --height 500 \
                --width 800 \
                " 
             ;;
        esac > "$WISOTOOL_WORKDIR"/zenity.sh

        for metadatafile in "$WISOTOOL_METADATA"/$WISOTOOL_CURMENU/*.vars
        do
            code=`basename $metadatafile .vars`
            (
            title='?'
            author='?'
            . $metadatafile
            echo -n " " FALSE \
                    $code \
                    "\"$title\"" \
                    "\"$publisher\"" \
                    "\"$year\"" \
                    "\"$media\""
            )
        done >> $WISOTOOL_WORKDIR/zenity.sh

        sh "$WISOTOOL_WORKDIR"/zenity.sh | tr '|' ' '
        ;;

    kdialog)
        (
        echo -n "kdialog --geometry 600x400+100+100 --title '$_W_msg_title' --separate-output --checklist '$_W_msg_body' "
        wisotool_list_all | sed 's/\([^ ]*\)  *\(.*\)/\1 "\1 - \2" off /' | tr '\012' ' '
        ) > "$WISOTOOL_WORKDIR"/kdialog.sh
        sh "$WISOTOOL_WORKDIR"/kdialog.sh
        ;;
    esac

    unset _W_msg_body _W_msg_title _W_msg_apps _W_msg_games
}

# Returns true if given verb has been registered
wisotool_metadata_exists()
{
   test -f "$WISOTOOL_METADATA"/*/$1.vars
}

# Returns true if given verb has been cached
# You must have already loaded its metadata before calling
wisotool_is_cached()
{
    # FIXME: also check file2... if given
    test -f "$W_CACHE/$1/$file1"
}

# Returns true if given verb has been installed
# You must have already loaded its metadata before calling
wisotool_is_installed()
{
    unset _W_file
    if test "$installed_exe1" 
    then
        _W_file="$installed_exe1"
    elif test "$installed_file1"
    then
        _W_file="$installed_file1"
    fi
    if test "$_W_file" 
    then
        _W_file_unix="`w_pathconv -u "$_W_file" | tr -d '\015' `"
        if test -f "$_W_file_unix"
        then
            unset _W_file _W_file_unix
            return 0  # installed
        fi
    fi
    unset _W_file _W_file_unix
    return 1  # not installed
}

# List verbs which are already fully cached locally
wisotool_list_cached()
{
    for _W_metadatafile in "$WISOTOOL_METADATA"/*/*.vars
    do
        # Use a subshell to avoid putting metadata in global space
        # If this is too slow, we can unset known metadata by hand
        (
        code=`basename $_W_metadatafile .vars`
        . $_W_metadatafile
        if wisotool_is_cached $code
        then
            echo $code
        fi
        )
    done | sort
    unset _W_metadatafile
}

# List verbs which are automatically downloadable, regardless of whether they're cached yet
wisotool_list_download()
{
    cd "$WISOTOOL_METADATA"
    grep -l 'media=.download' */*.vars | sed 's,.*/,,;s/\.vars//' | sort -u
}

# List verbs which are downloadable with user intervention, regardless of whether they're cached yet
wisotool_list_manual_download()
{
    cd "$WISOTOOL_METADATA"
    grep -l 'media=.manual_download' */*.vars | sed 's,.*/,,;s/\.vars//' | sort -u
}

wisotool_list_installed()
{
    (
    case $WISOTOOL_OPT_SHAREDPREFIX in
    0)
        # assume there's only one app per bottle (!), and list the bottles that have a matching run batch file.
        for verb in `ls "$W_PREFIXES_ROOT"/*/dosdevices/c:/run-*.bat | sed 's,.*/\([^/]*\)/dosdevices.*,\1,' `
        do
            test -f "$W_PREFIXES_ROOT"/$verb/dosdevices/c:/run-$verb.bat && echo $verb
        done
        ;;
    1)
        # List packages in default bottle
        for _W_metadatafile in "$WISOTOOL_METADATA"/*/*.vars
        do
            # Use a subshell to avoid putting metadata in global space
            # If this is too slow, we can unset known metadata by hand
            (
            code=`basename $_W_metadatafile .vars`
            . $_W_metadatafile
            if wisotool_is_installed $code
            then
                echo $code
            fi
            )
        done | sort
        unset _W_metadatafile
        ;;
    esac

    ) | sort -u
}

# Helper for adding a string to a list of flags
wisotool_append_to_flags()
{
    if test "$flags"
    then
        flags="$flags,"
    fi
    flags="${flags}$1"
}

# List all verbs in category WISOTOOL_CURMENU verbosely
# Format is "verb  title  (publisher, year) [flags]"
wisotool_list_all()
{
    case $WISOTOOL_CURMENU in
    main) echo "$WISOTOOL_CATEGORIES" | tr ' ' '\012' ; return;;
    esac

    case $LANG in
    da*) _W_cached="cached"   ; _W_download="kan hentes"    ;;
    de*) _W_cached="gecached" ; _W_download="herunterladbar";;
    *)   _W_cached="cached"   ; _W_download="downloadable"  ;;
    esac

    for _W_metadatafile in "$WISOTOOL_METADATA"/$WISOTOOL_CURMENU/*.vars
    do
        # Use a subshell to avoid putting metadata in global space
        # If this is too slow, we can unset known metadata by hand
        (
        code=`basename $_W_metadatafile .vars`
        . $_W_metadatafile

        # Compute cached and downloadable flags 
        flags=""
        test "$media" = "download" && wisotool_append_to_flags "$_W_download"
        wisotool_is_cached $code   && wisotool_append_to_flags "$_W_cached"
        test "$flags" && flags="[$flags]"

        printf "%-24s %s (%s, %s) %s\n" $code "$title" "$publisher" "$year" "$flags"
        )
    done
    unset _W_cached _W_metadatafile
}

# Abort if user doesn't own the given directory (or its parent, if it doesn't exist yet)
wisotool_die_if_user_not_dirowner()
{
    if test -d "$1"
    then
        _W_checkdir="$1"
    else
        # fixme: quoting problem?
        _W_checkdir=`dirname "$1"`
    fi
    _W_nuser=`id -u`
    _W_nowner=`ls -l -n -d -L "$_W_checkdir" | awk '{print $3}'`
    if test x$_W_nuser != x$_W_nowner
    then
        w_die "You (`id -un`) don't own $_W_checkdir.  Don't run this tool as another user!"
    fi
}

# See
# http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-119.pdf (iso9660)
# http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-167.pdf
# http://www.osta.org/specs/pdf/udf102.pdf
# http://www.ecma-international.org/publications/techreports/E-TR-071.htm

# Usage: read_bytes offset count device
wisotool_read_bytes()
{
    dd status=noxfer if=$3 bs=1 skip=$1 count=$2 2>/dev/null
}

# Usage: read_hex offset count device
wisotool_read_hex()
{
    hexdump -s $1 -n $2 -e $2'/1 "%01x " "\n"' $3 | sed 's/  *$//'
}

# Usage: read_decimal offset device
# Reads four byte word, outputs in decimal.
# Uses default endianness.  
# udf uses little endian words, so this only works on little endian machines.
wisotool_read_decimal()
{
    hexdump -s $1 -n 4 -e '1/4 "%4d " "\n"' $2
}

wisotool_read_udf_volume_name()
{
    # "Anchor volume descriptor pointer" starts at sector 256

    # AVDP Layout (ECMA-167 3/10.2):
    # size   offset   contents
    # 16     0        descriptor tag (id = 2)
    # 16     8        main (primary?) volume descriptor sequence extent
    # ...

    # descriptor tag layout (ECMA-167 3/7.2):
    # size   offset   contents
    # 2      0        TagIdentifier
    # ...

    # extent layout (ECMA-167 3/7.1):
    # size   offset   contents
    # 4      0        length (in bytes)
    # 8      4        location (in 2k sectors)

    # primary volume descriptor layout (ECMA-167 3/10.1):
    # size   offset   contents
    # 16     0        descriptor tag (id = 1)
    # ...
    # 32     24       volume identifier (dstring)

    # 1. check the 16 bit TagIdentifier of the descriptor tag, make sure it's 2
    tagid=`wisotool_read_hex 524288 2 $1`
    : echo tagid is $tagid
    case "$tagid" in
    "2 0") : echo Found AVDP ;;
    *) echo Did not find AVDP; exit 1;;
    esac

    # 2. read the location of the main volume descriptor:
    offset=`wisotool_read_decimal 524308 $1`
    : echo MVD is at sector $offset
    offset=`expr $offset \* 2048`
    : echo MVD is at byte $offset

    # 3. check the TagIdentifier of the MVD's descriptor tag, make sure it's 1
    tagid=`wisotool_read_hex $offset 2 $1`
    : echo tagid is $tagid
    case "$tagid" in
    "1 0") : echo Found MVD ;;
    *) echo Did not find MVD; exit 1;;
    esac

    # 4. Read whether the name is in 8 or 16 bit chars
    offset=`expr $offset + 24`
    width=`wisotool_read_hex $offset 1 $1`

    case $width in
    8) : ;;
    *) echo "Unhandled dvd volname character width '$width'"; exit 1;;
    esac

    # 5. Profit!
    offset=`expr $offset + 1`
    wisotool_read_bytes $offset 30 $1 | tr -d '\000' | sed 's/  *$//'
    echo ""
}

wisotool_read_volume_name()
{
    # ECMA-119 says that CD-ROMs have sector size 2k, and at sector 16 have:
    # size  offset contents
    #  1    0      Volume descriptor type (1 for primary volume descriptor)
    #  5    1      Standard identifier ("CD001" for iso9660)
    # ECMA-167, section 9.1.2, has a table of standard identifiers:
    # "BEA01": ecma-167 9.2, Beginning Extended Area Descriptor
    # "CD001": ecma-119
    # "CDW02": ecma-168

    std_id=`wisotool_read_bytes 32769 5 $1`
    : echo std_id is $std_id

    case $std_id in
    BEA01) wisotool_read_udf_volume_name $1; ;;
    *) echo "Unrecognized disk type $std_id"; exit 1 ;;
    esac
}

wisotool_volname()
{
    x=`volname $1 | sed 's/  *$//'`
    if test "x$x" = "x"
    then
        # UDF?  See https://bugs.launchpad.net/bugs/678419
        x=`wisotool_read_volume_name $1`
    fi
    echo $x
}

# Really, should take a volume name as argument, and use 'mount' to get 
# mount point if system automounted it.
wisotool_detect_optical_drive()
{
    case "$WISOTOOL_DEV" in
    "") ;;
    *) return ;;
    esac

    for WISOTOOL_DEV in /dev/cdrom /dev/dvd /dev/sr0
    do
        test -b $WISOTOOL_DEV && break
    done

    case "$WISOTOOL_DEV" in
    "x") w_die "can't find cd/dvd drive" ;;
    esac
}

wisotool_cache_iso()
{
    # WISOTOOL_IMG has already been set by w_mount
    _W_expected_volname="$1"

    wisotool_die_if_user_not_dirowner "$W_CACHE"
    wisotool_detect_optical_drive

    # Horrible hack for Gentoo - make sure we can read from the drive
    if ! test -r $WISOTOOL_DEV
    then
        case "$WISOTOOL_SUDO" in
        gksudo) $WISOTOOL_SUDO "chmod 666 $WISOTOOL_DEV" ;;
        *) $WISOTOOL_SUDO chmod 666 $WISOTOOL_DEV ;;
        esac
    fi

    while true
    do
        # Wait for user to insert disc.  
        # Sleep long to make it less likely to close the drive during insertion.
        while ! dd if=$WISOTOOL_DEV of=/dev/null count=1
        do
            sleep 5
        done

        # Some distros automount discs in /media, take advantage of that
        if test -d "/media/_W_expected_volname"
        then
            break
        fi
        # Otherwise try and read it straight from unmounted volume
        _W_volname=`wisotool_volname $WISOTOOL_DEV`
        if test "$_W_expected_volname" != "$_W_volname"
        then
            case $LANG in
            da*)  w_warn "Forkert disk [$_W_volname] indsat. Indsæt venligst disken [$_W_expected_volname]" ;;
            de*)  w_warn "Falsche Disk [$_W_volname] eingelegt.  Bitte legen Sie Disk [$_W_expected_volname] ein!" ;;
            *)    w_warn "Wrong disc [$_W_volname] inserted.  Please insert disc [$_W_expected_volname]" ;;
            esac

            sleep 10
        else
            break
        fi
    done

    # Copy disc to .iso file, display progress every 5 seconds
    # Use conv=noerror,sync to replace unreadable blocks with zeroes
    case $WISOTOOL_OPT_DD in
    dd)
      dd if=$WISOTOOL_DEV of="$W_CACHE"/temp.iso bs=2048 conv=noerror,sync &
      WISOTOOL_DD_PID=$!
      ;;
    ddrescue)
      if test "`which ddrescue`" = ""
      then
          w_die "Please install ddrescue first."
      fi
      ddrescue -v -b 2048 $WISOTOOL_DEV "$W_CACHE"/temp.iso &
      WISOTOOL_DD_PID=$!
      ;;
    esac

    # Note: if user presses ^C, wisotool_cleanup will call wisotool_iso_cleanup
    while ps -p $WISOTOOL_DD_PID > /dev/null 2>&1
    do
      sleep 5
      ls -l "$W_CACHE"/temp.iso
    done
    unset WISOTOOL_DD_PID

    mv "$W_CACHE"/temp.iso "$WISOTOOL_IMG"

    eject $WISOTOOL_DEV || true    # punt if eject not found (as on cygwin)
}

wisotool_mount_cached_iso()
{
    # On entry, WISOTOOL_IMG is already set
    w_umount

    if test "$WINE" = ""
    then
        w_die Windows not yet supported
    else
        # Linux
        # FIXME: find a way to mount or copy from image without sudo
        _W_USERID=`id -u`
        case "$WISOTOOL_SUDO" in
        gksudo)
          w_try $WISOTOOL_SUDO "mkdir -p $W_ISO_MOUNT_ROOT"
          w_try $WISOTOOL_SUDO "mount -o ro,loop,uid=$_W_USERID,unhide $WISOTOOL_IMG $W_ISO_MOUNT_ROOT"
          ;;
        *)
          w_try $WISOTOOL_SUDO mkdir -p $W_ISO_MOUNT_ROOT
          w_try $WISOTOOL_SUDO mount -o ro,loop,uid=$_W_USERID,unhide "$WISOTOOL_IMG" $W_ISO_MOUNT_ROOT
          ;;
        esac

        echo "Mounting as drive ${W_ISO_MOUNT_LETTER}:"
        # Gotta provide a symlink to the raw disc, else installers that check volume names will fail
        rm -f "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"*
        ln -sf "$WISOTOOL_IMG" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}::"
        ln -sf "$W_ISO_MOUNT_ROOT" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"
        unset _W_USERID
    fi
}

# List the currently mounted udf or iso9660 filesystems that match the given pattern
# Output format: 
#   dev mountpoint
#   dev mountpoint
#   ...
# Mountpoints may contain spaces.

wisotool_list_mounts()
{
    mount | egrep 'udf|iso9660' | sed 's,^\([^ ]*\) on \(.*\) type .*,\1 \2,'| grep "$1\$" 
}

# Return success and set _W_dev _W_mountpoint if volume $1 is mounted
# Note: setting variables as a way of returning results from a
# shell function exposed several bugs in most shells (except ksh!)
# related to implicit subshells.  It would be better to output
# one string to stdout instead.
wisotool_is_mounted()
{
    # First, check for matching mountpoint
    _W_tmp="`wisotool_list_mounts "$1"`"
    if test "$_W_tmp"
    then
        _W_dev=`echo $_W_tmp | sed 's/ .*//'`
        _W_mountpoint="`echo $_W_tmp | sed 's/^[^ ]* //'`"
        # Volume found!
        return 0
    fi

    # If that fails, read volume name the hard way for each volume
    # Have to use file to return results from implicit subshell
    rm -f /tmp/_W_tmp.$LOGNAME
    wisotool_list_mounts . | while true
    do
        IFS= read _W_tmp

        _W_dev=`echo $_W_tmp | sed 's/ .*//'`
        test "$_W_dev" || break
        _W_mountpoint="`echo $_W_tmp | sed 's/^[^ ]* //'`"
        _W_volname=`wisotool_volname $_W_dev`
        if test "$1" = "$_W_volname"
        then
            # Volume found!  Want to return from function here, but can't
            echo "$_W_tmp" > /tmp/_W_tmp.$LOGNAME
            break
        fi
    done

    if test -f /tmp/_W_tmp.$LOGNAME
    then
        # Volume found!  Return from function.  
        _W_dev=`cat /tmp/_W_tmp.$LOGNAME | sed 's/ .*//'`
        _W_mountpoint="`cat /tmp/_W_tmp.$LOGNAME | sed 's/^[^ ]* //'`"
        rm -f /tmp/_W_tmp.$LOGNAME
        return 0
    fi

    # Volume not found
    unset _W_dev _W_mountpoint _W_volname
    return 1
}

wisotool_mount_real_volume()
{
    _W_expected_volname="$1"

    # Wait for user to insert disc.  

    case $LANG in
    da*)_W_mountmsg="Indsæt og montér venligst disken '$_W_expected_volname' (krævet af pakken '$_PACKAGE')" ;;
    de*)_W_mountmsg="Disc '$_W_expected_volname' bitte einlegen und montieren (für Pakete '$W_PACKAGE')" ;;
    *)  _W_mountmsg="Please insert and mount volume '$_W_expected_volname' (needed for package '$W_PACKAGE')" ;;
    esac

    if test "$WINE" = ""
    then
        w_die Windows not yet supported
    else
        while ! wisotool_is_mounted "$_W_expected_volname"
        do
            w_warn "$_W_mountmsg"
            # In non-gui case, give user two seconds to futz with disc drive before spamming him again
            sleep 2
        done
        WISOTOOL_DEV=$_W_dev
        W_ISO_MOUNT_ROOT="$_W_mountpoint"

        # Gotta provide a symlink to the raw disc, else installers that check volume names will fail
        rm -f "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"*
        ln -sf "$WISOTOOL_DEV" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}::"
        ln -sf "$W_ISO_MOUNT_ROOT" "$WINEPREFIX/dosdevices/${W_ISO_MOUNT_LETTER}:"
    fi

    # FIXME: need to remount some discs with unhide option, 
    # add that as option to w_mount

    unset _W_mountmsg
}

wisotool_cleanup()
{
    test "$WISOTOOL_CACHE_SYMLINK" && rm -f "$WISOTOOL_CACHE_SYMLINK"
    rm -rf "$WISOTOOL_WORKDIR"
}

wisotool_kill_handler()
{
    #echo "Caught signal, cleaning up."
    case "$WISOTOOL_DD_PID" in
    "") ;;
    *) kill $WISOTOOL_DD_PID ;;
    esac
    wisotool_cleanup
    #echo "Done cleanup, quitting."
    exit
}

wisotool_init()
{
    #---- Private Variables ----

    # Ephemeral files for this run
    WISOTOOL_WORKDIR=/tmp/w.$LOGNAME.$$
    rm -rf "$WISOTOOL_WORKDIR"

    # Registering a verb creates a file in WISOTOOL_METADATA
    WISOTOOL_METADATA="$WISOTOOL_WORKDIR/metadata"

    # The list of categories is also hardcoded in wisotool_mainmenu() :-(
    WISOTOOL_CATEGORIES="apps benchmarks dlls fonts games steam"
    for _W_cat in $WISOTOOL_CATEGORIES
    do
        mkdir -p "$WISOTOOL_METADATA"/$_W_cat
    done
    WISOTOOL_COMMANDMENUS="run uninstall"

    # Which subdirectory of WISOTOOL_METADATA is currently active (or main, if none)
    WISOTOOL_CURMENU=main

    # Delete work directory after each run, on exit either graceful or abrupt
    trap wisotool_kill_handler 0 1 2 3 6

    # Which GUI helper to use (none/zenity/kdialog).  See wisotool_detect_gui.
    WISOTOOL_GUI=none

    WISOTOOL_DIR=${WISOTOOL_DIR:-$HOME/.local/wisotool}

    # Whether to always cache cached iso's (1) or only use cache if present (0)
    # Can be inherited from environment or set via -k, defaults to off
    WISOTOOL_OPT_KEEPISOS=${WISOTOOL_OPT_KEEPISOS:-0}

    # what program to use to make disc image (dd or ddrescue)
    WISOTOOL_OPT_DD=${WISOTOOL_OPT_DD:-dd}

    # whether to use shared wineprefix (1) or unique wineprefix for each app (0)
    WISOTOOL_OPT_SHAREDPREFIX=${WISOTOOL_OPT_SHAREDPREFIX:-1}

    # Mac folks tend to not have sha1sum, but we can make do with openssl
    if [ -x "`which sha1sum 2>/dev/null`" ]
    then
       WISOTOOL_SHA1SUM="sha1sum"
    elif [ -x "`which openssl 2>/dev/null`" ]
    then
       WISOTOOL_SHA1SUM="openssl dgst -sha1"
    else
       w_die "No sha1sum utility available."
    fi

    # Which sourceforge mirror to use.  Rotate based on time, since
    # their mirror picker sometimes persistantly sends you to a broken
    # mirror.
    case `date +%S` in
    *[3])  WISOTOOL_SOURCEFORGE=http://easynews.dl.sourceforge.net/sourceforge ;;
    *)     WISOTOOL_SOURCEFORGE=http://downloads.sourceforge.net;;
    esac

    #---- Public Variables ----

    # System-specific variables
    case "$OS" in
     "Windows_NT")
        WINE=""
        W_DRIVE_C="C:/"
        ;;
     *)
        WINE=${WINE:-wine}
        WINEPREFIX="${WINEPREFIX:-$HOME/.wine}"
        W_DRIVE_C="$WINEPREFIX/dosdevices/c:"
        # This needs to go somewhere else soon, like ~/.local/wineprefixes
        W_PREFIXES_ROOT="${W_PREFIXES_ROOT:-$HOME/prefixes}"
        ;;
    esac
    # Verbs can rely on W_TMP being empty at entry, deleted after return, and a subdir of C:
    # Kludge: use _temp instead of temp to avoid \t expansion in w_try
    W_TMP="$W_DRIVE_C/windows/_temp"
    W_TMP_WIN="C:\\windows\\_temp"

    W_WINDIR_UNIX="$W_DRIVE_C/windows"

    # Where application installers are cached
    # FIXME: move those tr's and sed's into w_pathconv, if they're still needed?
    W_CACHE="${W_CACHE:-$WISOTOOL_DIR/cache}"
    W_CACHE_WIN="`w_pathconv -w $W_CACHE | tr '\012' ' ' | sed 's/ $//'`"

    # The folder-name is localized!
    W_PROGRAMS_WIN="`wisotool_early_wine cmd.exe /c echo "%ProgramFiles%" | tr -d '\015'`"
    case "$W_PROGRAMS_WIN" in
    "") w_die "$WINE cmd.exe /c echo '%ProgramFiles%' returned empty string" ;;
    %*) w_die "$WINE cmd.exe /c echo '%ProgramFiles%' returned unexpanded string... do you own the parent of $WINEPREFIX ?" ;;
    esac
    # FIXME: move that tr into w_pathconv, if it's still needed?
    W_PROGRAMS_UNIX="`w_pathconv -u "$W_PROGRAMS_WIN" | tr -d '\015' `"

    # 64 bit windows has a second directory for program files
    W_PROGRAMS_X86_WIN="${W_PROGRAMS_WIN} (x86)"
    W_PROGRAMS_X86_UNIX="${W_PROGRAMS_UNIX} (x86)"
    if ! test -d "$W_PROGRAMS_X86_UNIX"
    then
        W_PROGRAMS_X86_WIN="${W_PROGRAMS_WIN}"
        W_PROGRAMS_X86_UNIX="${W_PROGRAMS_UNIX}"
    fi

    W_APPDATA_WIN="`wisotool_early_wine cmd.exe /c echo "%AppData%" | tr -d '\015'`"
    W_APPDATA_UNIX="`w_pathconv -u "$W_APPDATA_WIN" | tr -d '\015' `"

    # FIXME: get fonts path from SHGetFolderPath
    # See also http://blogs.msdn.com/oldnewthing/archive/2003/11/03/55532.aspx
    W_FONTSDIR_WIN="c:\\windows\\Fonts"
 
    # FIXME: just convert path from windows to unix?
    # Did the user rename Fonts to fonts?
    if test ! -d "$W_WINDIR_UNIX"/Fonts && test -d "$W_WINDIR_UNIX"/fonts
    then
        W_FONTSDIR_UNIX="$W_WINDIR_UNIX"/fonts
    else
        W_FONTSDIR_UNIX="$W_WINDIR_UNIX"/Fonts
    fi
    mkdir -p "${W_FONTSDIR_UNIX}"

    # FIXME: don't hardcode
    W_PROGRAMS_DRIVE=c

    # Whether to automate installs (0=no, 1=yes)
    W_OPT_UNATTENDED=${W_OPT_UNATTENDED:-0}

    WISOTOOL_WINETRICKS="$WISOTOOL_SRCDIR/winetricks"
    if ! test -f "$WISOTOOL_WINETRICKS"
    then
        WISOTOOL_WINETRICKS="$W_CACHE/winetricks/winetricks"
        w_download winetricks http://kegel.com/wine/winetricks
    fi

    # Handle case where z: doesn't exist
    case "$W_CACHE_WIN" in
    ""|*\?\\unix*)
        # W_CACHE isn't accessible via a drive letter mapping, so make one,
        # but be sure to clean it up later.
        for letter in y x w v u t s r q
        do
            if ! test -d "$WINEPREFIX"/dosdevices/${letter}:
            then
                WISOTOOL_CACHE_SYMLINK="$WINEPREFIX"/dosdevices/${letter}:
                ln -sf "$W_CACHE" "$WISOTOOL_CACHE_SYMLINK"
                W_CACHE_WIN=${letter}:
                break
            fi
        done
        ;;
    esac

    # Overridden for windows
    W_ISO_MOUNT_ROOT=/mnt/wisotool
    W_ISO_MOUNT_LETTER=i

    # Win(e) 32/64?
    # Using the variable W_SYSTEM32_DLLS instead of SYSTEM32 because some stuff does go under system32 for both arch's
    # e.g., spool/drivers/color
    if test -d "$W_DRIVE_C/windows/syswow64"
    then
        W_ARCH=win64
        W_SYSTEM32_DLLS="$W_WINDIR_UNIX/syswow64"
        W_SYSTEM32_DLLS_WIN="C:\\windows\\syswow64"
        W_SYSTEM64_DLLS="$W_WINDIR_UNIX/system32"
    else
        W_ARCH=win32
        W_SYSTEM32_DLLS="$W_WINDIR_UNIX/system32"
        W_SYSTEM32_DLLS_WIN="C:\\windows\\system32"
    fi
}

wisotool_usage()
{
    case $LANG in
    da*)
        cat <<_EOF_
Brug: $0 [tilvalg] [verbum|sti-til-verbum] ...
Kører de angivne verber.  Hvert verbum installerer et program eller ændrer en indstilling.
Tilvalg:
-k|--keep_isos: lagr iso'er lokalt (muliggør senere installation uden disk)
-q|--unattended: stil ingen spørgsmål, installér bare automatisk
-r|--ddrescue: brug alternativ disk-tilgangsmetode (hjælper i tilfælde af en ridset disk)
-v|--verbose: vis alle kommandoer som de bliver udført
-V|--version: vis programversionen og afslut
-h|--help: vis denne besked og afslut
Diverse verber:
list: vis en liste over alle verber
list-cached: vis en liste over verber for allerede-hentede installationsprogrammer
list-download: vis en liste over verber for programmer der kan hentes
list-manual-download: list applications which can be downloaded with some help from the user
list-installed: list already-installed applications
_EOF_
        ;;
    de*)
        cat <<_EOF_
Usage: $0 [options] [verb|path-to-verb] ...
Angegebene Verben ausführen.
Jeder Verb installiert z.B. eine Anwendung oder ändert eine Einstellung.
Optionen:
-k|--keep_isos: isos local speichern (erlaubt spätere Installierung ohne Disk)
-q|--unattended: keine Fragen stellen, alles automatisch installieren
-r|--ddrescue: alternative Zugriffsmodus (hilft bei gekratzten Disks)
-v|--verbose: alle ausgeführten Kommandos anzeigen
-V|--version: Programmversion anzeigen
-h|--help: diese Hilfemeldung anzeigen
Sonstige Verben:
apps: Typ 'Andwendungen' auswählen
games: Typ 'Spiele' auswählen
list: Verben von ausgewählte Typ auflisten
list-cached: Verben für schon gecachte Installers auflisten
list-download: Verben für herunterladbare Anwendungen auflisten
list-manual-download: list applications which can be downloaded with some help from the user
list-installed: Verben für schon installlierte Programme auflisten
_EOF_
        ;;
    *)
        cat <<_EOF_
Usage: $0 [options] [verb|path-to-verb] ...
Executes given verbs.  Each verb installs an application or changes a setting.
Options:
-s|--sharedprefix: don't give each app its own wineprefix
-k|--keep_isos: cache isos (allows later installation without disc)
-q|--unattended: don't ask any questions, just install automatically
-r|--ddrescue: alternate method of disc access (helps with scratched discs)
-v|--verbose: echo all commands as they are executed
-V|--version: display version and exit
-h|--help: display this message and exit
Miscellaneous verbs:
apps: select type 'apps'
games: select type 'games'
list: list verbs from selected category
list-cached: list cached-and-ready-to-install applications
list-download: list applications which can be downloaded automatically
list-manual-download: list applications which can be downloaded with some help from the user
list-installed: list already-installed applications
_EOF_
        ;;
    esac
}

wisotool_handle_option()
{
    case "$1" in
    -s|--sharedprefix) WISOTOOL_OPT_SHAREDPREFIX=1 ;;
    -r|--ddrescue) WISOTOOL_OPT_DD=ddrescue ;;
    -k|--keep_isos) WISOTOOL_OPT_KEEPISOS=1 ;;
    -q|--unattended) W_OPT_UNATTENDED=1
                     W_UNATTENDED_DASH_Q="-q"
                     W_UNATTENDED_SLASH_Q="/q"
                     W_UNATTENDED_SLASH_S="/S"
                     W_UNATTENDED_DASH_SILENT="-silent"
                     W_UNATTENDED_SLASH_SILENT="/silent"
                     ;;  # fixme: can't make this default easily with these here
    -v|--verbose) set -x ;;
    -V|--version) wisotool_print_version ; exit 0;;
    -h|--help) wisotool_usage ; exit 0 ;;
    -*) w_die "unknown option $1" ;;
    *) return 1 ;;
    esac
    return 0
}

# Must initialize variables before calling w_metadata
if ! test "$WISOTOOL_LIB"
then
    WISOTOOL_SRCDIR=`dirname $0`
    WISOTOOL_SRCDIR=`cd $WISOTOOL_SRCDIR; /bin/pwd`

    # Handle options before init, to avoid starting wine for --help or --version
    while wisotool_handle_option $1
    do
        shift
    done

    wisotool_init
fi

wisotool_run_app()
{
    # Find the app
    case $WISOTOOL_OPT_SHAREDPREFIX in
    0)
        WISOTOOL_RUN_WINEPREFIX="$W_PREFIXES_ROOT"/$1
        app="$WISOTOOL_RUN_WINEPREFIX"/dosdevices/c:/run-$1.bat 
        ;;
    1)
        WISOTOOL_RUN_WINEPREFIX="$WINEPREFIX"
        app="$W_DRIVE_C/run-$1.bat"
        ;;
    esac
    if ! test -f "$app"
    then
        w_die "Can't find app $1 (looked for $app)"
    fi
    WINEPREFIX="$WISOTOOL_RUN_WINEPREFIX" $WINE cmd /c C:\\run-$1.bat
}

wisotool_install_app()
{
    case $LANG in
    da*) fail_msg="Installationen af pakken $W_PACKAGE fejlede" ;;
    de*) fail_msg="Installieren von Pakete $W_PACKAGE gescheitert" ;;
    *)   fail_msg="Failed to install package $W_PACKAGE" ;;
    esac

    W_TMP="$W_DRIVE_C/windows/_temp/_$W_PACKAGE"
    W_TMP_WIN="C:\\windows\\_temp\\_$W_PACKAGE"
    rm -rf "$W_TMP"
    mkdir -p "$W_TMP"

    # FIXME: initialize a new wineprefix for this app, set lots of global variables
    if ! w_call $W_PACKAGE
    then
        w_die "$fail_msg"
    fi

    # User-specific postinstall hook.
    # Source it so the script can call w_download() if needed.
    postfile="$WISOTOOL_POST/$W_PACKAGE/$W_PACKAGE-postinstall.sh"
    if test -f "$postfile"
    then
        chmod +x "$postfile"
        ( . "$postfile" )
    fi

    rm -rf "$W_TMP"
    W_TMP="$W_DRIVE_C/windows/_temp"
    W_TMP_WIN="C:\\windows\\_temp"
}

wisotool_uninstall_app()
{
    # Find the app
    case $WISOTOOL_OPT_SHAREDPREFIX in
    0)
        WISOTOOL_RUN_WINEPREFIX="$W_PREFIXES_ROOT"/$1
        app="$WISOTOOL_RUN_WINEPREFIX"/dosdevices/c:/run-$1.bat 
        ;;
    1)
        w_die "Sorry, this tool can't uninstall apps from a shared wineprefix"
        ;;
    esac
    if ! test -f "$app"
    then
        w_die "Can't find app $1 (looked for $app)"
    fi
    rm -rf "$WISOTOOL_RUN_WINEPREFIX"
}

#---- Builtin Verbs ----

#----------------------------------------------------------------
# Runtimes
#----------------------------------------------------------------

#----- common download for several verbs

helper_directx_dl()
{
    # February 2010 DirectX 9c User Redistributable
    # http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=0cef8180-e94a-4f56-b157-5ab8109cb4f5
    # FIXME: none of the verbs that use this will show download status right
    # until file1 metadata is extended to handle common cache dir
    w_download directx9 http://download.microsoft.com/download/E/E/1/EE17FF74-6C45-4575-9CF4-7FC2597ACD18/directx_feb2010_redist.exe a97c820915dc20929e84b49646ec275760012a42

    DIRECTX_NAME=directx_feb2010_redist.exe
}

w_metadata  adobeair dlls \
   title="Adobe AIR 2.5.1" \
   publisher="Adobe" \
   year="2010" \
   media="download" \
   file1="AdobeAIRInstaller.exe" \
   installed_file1="$W_PROGRAMS_X86_WIN\\Common Files\\Adobe AIR\\Versions\\1.0\\Adobe AIR.dll"

load_adobeair()
{
    # 2010-02-02: sha1sum 5c95f51a680f8c175a92755238127be4ad22c53b
    # 2010-02-20: sha1sum 6f03e723bd855abbe00eb8fdf22da54fb49c62db
    # 2010-07-29: 2.0.2 sha1sum 7b93aedaf48ad7854940e7a4e7d9394a255e888b
    # 2010-12-08: 2.1.5 sha1sum 2664207ca8e836f5070ee356064829a39785a92e
    w_download adobeair http://airdownload.adobe.com/air/win/download/2.5.1/AdobeAIRInstaller.exe 2664207ca8e836f5070ee356064829a39785a92e
    w_try $WINE "$W_CACHE"/adobeair/AdobeAIRInstaller.exe $W_UNATTENDED_DASH_SILENT
}

#----------------------------------------------------------------

w_metadata amstream dlls \
   title="MS amstream.dll" \
   publisher="Microsoft" \
   year="2010" \
   media="download" \
   file1="../directx9/directx_feb2010_redist.exe" \
   installed_file1="$W_SYSTEM32_DLLS_WIN"\\amstream.dll

load_amstream()
{
    helper_directx_dl
    mkdir "$W_CACHE"/amstream   # kludge so test -f $file1 works

    w_try_cabextract -d "$W_TMP" -L -F dxnt.cab "$W_CACHE"/directx9/$DIRECTX_NAME
    w_try_cabextract -d "$W_SYSTEM32_DLLS" -L -F 'amstream.dll' "$W_TMP/dxnt.cab"
    w_try_regsvr amstream.dll
    
    w_override_dlls native amstream
}

#----------------------------------------------------------------
w_metadata  art2kmin dlls \
   title="MS Access 2007 runtime" \
   publisher="Microsoft" \
   year="2007" \
   media="download" \
   file1="AccessRuntime.exe" \
   installed_file1="$W_PROGRAMS_X86_WIN\\Common Files\\Microsoft Shared\\OFFICE12\\ACEES.DLL"

load_art2kmin()
{
    # See http://www.microsoft.com/downloads/details.aspx?familyid=d9ae78d9-9dc6-4b38-9fa6-2c745a175aed&displaylang=en
    w_download art2kmin http://download.microsoft.com/download/D/2/A/D2A2FC8B-0447-491C-A5EF-E8AA3A74FB98/AccessRuntime.exe 571811b7536e97cf4e4e53bbf8260cddd69f9b2d
    cd "$W_CACHE"/art2kmin
    w_try $WINE AccessRuntime.exe $W_UNATTENDED_SLASH_Q
}

#----------------------------------------------------------------

w_metadata  atmlib dlls \
   title="Adobe Type Manager" \
   publisher="Adobe" \
   year="2009" \
   media="download" \
   file1="W2KSP4_EN.EXE" \
   installed_file1="$W_SYSTEM32_DLLS/atmlib.dll"

load_atmlib()
{
    # http://www.microsoft.com/downloads/details.aspx?FamilyID=1001AAF1-749F-49F4-8010-297BD6CA33A0&displaylang=en
    # FIXME: This is a huge download for a single dll.
    # FIXME: This download is also used to get msasn1.dll, but we can't download into common cache directory until the file1 metadata download check is extended to handle that.  It'd be better to not need the huge download.
    w_download atmlib http://download.microsoft.com/download/E/6/A/E6A04295-D2A8-40D0-A0C5-241BFECD095E/W2KSP4_EN.EXE fadea6d94a014b039839fecc6e6a11c20afa4fa8
    cd "$W_TMP"
    w_try_cabextract "$W_CACHE"/atmlib/W2KSP4_EN.EXE i386/atmlib.dl_
    w_try cp atmlib.dll "$W_SYSTEM32_DLLS"
}

#----------------------------------------------------------------

w_metadata  glut dlls \
   title="The glut utility library for OpenGL" \
   publisher="Mark J. Kilgard" \
   year="2001" \
   media="download" \
   file1="glut-3.7.6-bin.zip" \
   installed_file1="c:\\glut-3.7.6-bin\\glut32.lib"

load_glut()
{
    w_download glut http://www.xmission.com/~nate/glut/glut-3.7.6-bin.zip fb4731885c05b3cf2c79e85aabe8fc9949616ef4
    w_try unzip -d "$W_DRIVE_C" "$W_CACHE"/glut/glut-3.7.6-bin.zip
    w_try cp "$W_DRIVE_C"/glut-3.7.6-bin/glut32.dll "$W_SYSTEM32_DLLS"
    w_warn "If you want to compile glut programs, add c:/glut-3.7.6-bin to LIB and INCLUDE"
}

#----------------------------------------------------------------

w_metadata  mfc40 dlls \
   title="MS mfc40 (Microsoft Foundation Classes from Visual C++ 4.0)" \
   publisher="Microsoft" \
   year="2004" \
   media="download" \
   file1="ole2v.exe" \
   installed_file1="$W_SYSTEM32_DLLS/MFC40.DLL"

load_mfc40()
{
    # See http://support.microsoft.com/kb/122244
    w_download mfc40 http://download.microsoft.com/download/ole/ole2v/3.5/w351/en-us/ole2v.exe c6cac71f32405ccb09c6f375e0738e6e13f073e4
    w_try unzip -d "$W_TMP" "$W_CACHE"/mfc40/ole2v.exe
    w_try cp -f "$W_TMP"/MFC40.DLL "$W_SYSTEM32_DLLS"
}

#----------------------------------------------------------------

w_metadata shockwave dlls \
   title="Shockwave" \
   publisher="Adobe" \
   year="2010" \
   media="download" \
   file1="sw_lic_full_installer.msi" \
   installed_file1="$W_SYSTEM32_DLLS_WIN\\Adobe\\Shockwave 11\\shockwave_Projector_Loader.dcr"

load_shockwave() {
    # Not silent enough, use msi instead
    #w_download shockwave http://fpdownload.macromedia.com/get/shockwave/default/english/win95nt/latest/Shockwave_Installer_Full.exe 840e34e9b067cf247bfa9092665b8966158f38e3
    #w_try $WINE "$W_CACHE"/Shockwave_Installer_Full.exe $W_UNATTENDED_SLASH_S
    # old sha1sum: 6a91a9da4b54c3fdc97130a15e1a173117e5f4ff
    # 2009-07-31 sha1sum: 0bb506ef67a268e8d3fb6c7ce556320ee10b9da5
    # 2009-12-13 sha1sum: d35649883bf13cb1a86f5650e1050d15533ac0f4
    # 2010-01-23 sha1sum: 4a837d238c28c5f345d73f105711f20c6d059273  
    # 2010-05-15 sha1sum: bdce02afc82233801e84137e78c2c5fe574db253
    # 2010-09-02 sha1sum: fed20eccc29fec2f64162b7265343514d43884bc
    # 2010-11-03 sha1sum: 2ff28665543e80f3bd4ff1933ac05ec9314aaac6

    w_download shockwave http://fpdownload.macromedia.com/get/shockwave/default/english/win95nt/latest/sw_lic_full_installer.msi 2ff28665543e80f3bd4ff1933ac05ec9314aaac6
    cd "$W_CACHE"/shockwave
    w_try $WINE msiexec /i sw_lic_full_installer.msi $W_UNATTENDED_SLASH_Q
}

#----------------------------------------------------------------

w_metadata  vcrun6 dlls \
   title="Visual C++ 6 sp4 libraries (mfc42, msvcp60, msvcrt)" \
   publisher="Microsoft" \
   year="2000" \
   media="download" \
   file1="vc6redistsetup_enu.exe" \
   installed_file1="$W_SYSTEM32_DLLS_WIN"\\mfc42u.dll

load_vcrun6()
{
    # Load the Visual C++ 6 runtime libraries, including the elusive mfc42u.dll

    if test ! -f "$W_CACHE"/vcrun6/vcredist.exe
    then
       w_download vcrun6 http://download.microsoft.com/download/vc60pro/update/1/w9xnt4/en-us/vc6redistsetup_enu.exe 382c8f5a7f41189af8d4165cf441f274b7e2a457

       w_try $WINE "$W_CACHE"/vcrun6/vc6redistsetup_enu.exe "/T:$W_TMP_WIN" /c $W_UNATTENDED_SLASH_Q
       if test ! -f "$W_TMP"/vcredist.exe
       then
          w_die vcredist.exe not found
       fi
       mv "$W_TMP"/vcredist.exe "$W_CACHE"/vcrun6
    fi
    # Delete some fake dlls to avoid vcredist installer warnings
    rm -f "$W_SYSTEM32_DLLS"/comcat.dll
    rm -f "$W_SYSTEM32_DLLS"/msvcrt.dll
    rm -f "$W_SYSTEM32_DLLS"/oleaut32.dll
    rm -f "$W_SYSTEM32_DLLS"/olepro32.dll
    rm -f "$W_SYSTEM32_DLLS"/stdole2.tlb
    $WINE "$W_CACHE"/vcrun6/vcredist.exe

    status=$?
    case $status in
    0|43) ;;
    *) w_die vcrun6 installation failed
    esac

    # And then some apps need mfc42u.dll, dunno what right way
    # is to get it, vcredist doesn't install it by default?
    w_try_cabextract "$W_CACHE"/vcrun6/vcredist.exe -d "$W_SYSTEM32_DLLS" -F mfc42u.dll

    w_override_dlls native,builtin msvcrt
}

#----------------------------------------------------------------

w_metadata  vcrun2003 dlls \
   title="Visual C++ 2003 libraries (mfc71,msvcp71,msvcr71)" \
   publisher="Microsoft" \
   year="2003" \
   media="download" \
   file1="BZEditW32_1.6.5_Installer.exe" \
   installed_file1="$W_SYSTEM32_DLLS_WIN"\\msvcp71.dll

load_vcrun2003()
{
    # Load the Visual C++ 2003 runtime libraries
    # Sadly, I know of no Microsoft URL for these
    echo "Installing BZFlag (which comes with the Visual C++ 2003 runtimes)"
    w_download vcrun2003 $WISOTOOL_SOURCEFORGE/bzflag/BZEditW32_1.6.5_Installer.exe bdd1b32c4202fd77e6513fd507c8236888b09121
    w_try $WINE "$W_CACHE"/vcrun2003/BZEditW32_1.6.5_Installer.exe $W_UNATTENDED_SLASH_S
    w_try cp "$W_PROGRAMS_X86_UNIX/BZEdit1.6.5"/m*71* "$W_SYSTEM32_DLLS"
}

#----------------------------------------------------------------

w_metadata vcrun2005 dlls \
   title="Visual C++ 2005 libraries (mfc80,msvcp80,msvcr80)" \
   publisher="Microsoft" \
   year="2005" \
   media="download" \
   file1="vcredist_x86.exe" \
   installed_file1="c:\\windows\\winsxs\\x86_Microsoft.VC80.MFC_1fc8b3b9a1e18e3b_8.0.50727.4053_x-ww_b77cec8e\\mfc80.dll"

load_vcrun2005()
{
    # SP1 + ATL security fix build 4053 (MS09-035)
    # See http://www.microsoft.com/downloads/details.aspx?familyid=766A6AF7-EC73-40FF-B072-9112BAB119C2
    w_download vcrun2005 http://download.microsoft.com/download/6/B/B/6BB661D6-A8AE-4819-B79F-236472F6070C/vcredist_x86.exe e052789ebad7dc8d6f8505a9295b0576babd125e
    cd "$W_CACHE"/vcrun2005
    w_override_dlls native,builtin msvcr80
    w_try $WINE vcredist_x86.exe $W_UNATTENDED_SLASH_Q
}

#----------------------------------------------------------------

w_metadata vcrun2008 dlls \
   title="Visual C++ 2008 libraries (mfc90,msvcp90,msvcr90)" \
   publisher="Microsoft" \
   year="2008" \
   media="download" \
   file1="vcredist_x86.exe" \
   installed_file1="C:\\windows\\winsxs\\x86_Microsoft.VC90.MFC_1fc8b3b9a1e18e3b_9.0.30729.4148_x-ww_a57c1f53\\mfc90.dll"

load_vcrun2008()
{
    # SP1 + ATL security fix build 4148 (MS09-035)
    # See http://www.microsoft.com/downloads/details.aspx?familyid=2051a0c1-c9b5-4b0a-a8f5-770a549fd78c
    w_download vcrun2008 http://download.microsoft.com/download/9/7/7/977B481A-7BA6-4E30-AC40-ED51EB2028F2/vcredist_x86.exe bd18409cfe75b88c2a9432d36d96f4bf125a3237
    w_override_dlls native,builtin msvcr90
    cd "$W_CACHE"/vcrun2008
    w_try $WINE vcredist_x86.exe $W_UNATTENDED_SLASH_Q
}

#----------------------------------------------------------------

w_metadata vcrun2010 dlls \
   title="Visual C++ 2010 libraries (mfc100,msvcp100,msvcr100)" \
   publisher="Microsoft" \
   year="2010" \
   media="download" \
   file1="vcredist_x86.exe" \
   installed_file1="$W_SYSTEM32_DLLS_WIN"\\mfc100.dll

load_vcrun2010()
{
    # See http://www.microsoft.com/downloads/details.aspx?FamilyID=a7b7a05e-6de6-4d3a-a423-37bf0912db84
    w_download vcrun2010 http://download.microsoft.com/download/5/B/C/5BC5DBB3-652D-4DCE-B14A-475AB85EEF6E/vcredist_x86.exe 372d9c1670343d3fb252209ba210d4dc4d67d358

    if w_workaround_wine_bug 23427  # fixed in wine-1.3.5
    then
        w_try_winetricks msxml3
    fi

    w_override_dlls native,builtin msvcr100
    cd "$W_CACHE"/vcrun2010
    w_try $WINE vcredist_x86.exe $W_UNATTENDED_SLASH_Q
}

#----------------------------------------------------------------

w_metadata wsh57 dlls \
   title="MS Windows Scripting Host 5.7" \
   publisher="Microsoft" \
   year="2007" \
   media="download" \
   file1="scripten.exe" \
   installed_file1="$W_SYSTEM32_DLLS_WIN"\\scrrun.dll

load_wsh57()
{
    # See also http://www.microsoft.com/downloads/details.aspx?FamilyID=47809025-D896-482E-A0D6-524E7E844D81&displaylang=en
    w_download wsh57 http://download.microsoft.com/download/4/4/d/44de8a9e-630d-4c10-9f17-b9b34d3f6417/scripten.exe b15c6a834b7029e2dfed22127cf905b06857e6f5

    w_try_cabextract -d "$W_SYSTEM32_DLLS" "$W_CACHE"/wsh57/scripten.exe 

    # Wine doesn't provide the other dll's (yet?)
    w_override_dlls native,builtin jscript.dll
    w_try_regsvr dispex.dll jscript.dll scrobj.dll scrrun.dll vbscript.dll wshcon.dll wshext.dll
}

#----------------------------------------------------------------
# Fonts
#----------------------------------------------------------------

w_metadata baekmuk fonts \
   title="Baekmuk Korean fonts" \
   publisher="Wooderart Inc. / kldp.net" \
   year="1999" \
   media="download" \
   file1="ttf-baekmuk_2.2.orig.tar.gz" \
   installed_file1="$W_FONTSDIR_WIN"\\batang.ttf

load_baekmuk()
{
    # See http://kldp.net/projects/baekmuk for project page
    # Need to download from Debian as the project page has unique captcha tokens per visitor
    w_download baekmuk http://ftp.debian.org/debian/pool/main/t/ttf-baekmuk/ttf-baekmuk_2.2.orig.tar.gz afdee34f700007de6ea87b43c92a88b7385ba65b
    cd "$W_TMP/"
    gunzip -dc "$W_CACHE/baekmuk/ttf-baekmuk_2.2.orig.tar.gz" | tar -xf -
    w_try mv baekmuk-ttf-2.2/ttf/*.ttf "$W_FONTSDIR_UNIX"
    w_register_font batang.ttf "Baekmuk Batang"
    w_register_font gulim.ttf "Baekmuk Gulim"
    w_register_font dotum.ttf "Baekmuk Dotum"
    w_register_font hline.ttf "Baekmuk Headline"
}

#----------------------------------------------------------------

w_metadata corefonts fonts \
   title="MS Arial, Courier, Times fonts" \
   publisher="Microsoft" \
   year="2008" \
   media="download" \
   file1="arial32.exe" \
   installed_file1="$W_FONTSDIR_WIN"\\Arial.TTF

load_corefonts()
{
    # See http://corefonts.sf.net
    # TODO: let user pick mirror,
    # see http://corefonts.sourceforge.net/msttcorefonts-2.0-1.spec for how
    # TODO: add more fonts

    # Added More Fonts (see msttcorefonts)
    # [*] Pointed w_download locations to sites that actually contained the
    # fonts to w_download (as of 04-03-2008)
    #w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/andale32.exe c4db8cbe42c566d12468f5fdad38c43721844c69
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/arial32.exe 6d75f8436f39ab2da5c31ce651b7443b4ad2916e
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/arialb32.exe d45cdab84b7f4c1efd6d1b369f50ed0390e3d344
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/comic32.exe 2371d0327683dcc5ec1684fe7c275a8de1ef9a51
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/courie32.exe 06a745023c034f88b4135f5e294fece1a3c1b057
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/georgi32.exe 90e4070cb356f1d811acb943080bf97e419a8f1e
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/impact32.exe 86b34d650cfbbe5d3512d49d2545f7509a55aad2
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/times32.exe 20b79e65cdef4e2d7195f84da202499e3aa83060
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/trebuc32.exe 50aab0988423efcc9cf21fac7d64d534d6d0a34a
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/verdan32.exe f5b93cedf500edc67502f116578123618c64a42a
    w_download corefonts $WISOTOOL_SOURCEFORGE/corefonts/webdin32.exe 2fb4a42c53e50bc70707a7b3c57baf62ba58398f

    # Natively installed versions of these fonts will cause the installers
    # to exit silently. Because there are apps out there that depend on the
    # files being present in the Windows font directory we use cabextract
    # to obtain the files and register the fonts by hand.

    # Andale needs a FontSubstitutes entry
    # w_try_cabextract --directory="$W_TMP" "$W_CACHE"/corefonts/andale32.exe

    # Display EULA
    test x"$W_UNATTENDED_SLASH_Q" = x"" || w_try $WINE "$W_CACHE"/corefonts/arial32.exe $W_UNATTENDED_SLASH_Q

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/arial32.exe
    w_try cp -f "$W_TMP"/Arial*.TTF "$W_FONTSDIR_UNIX"
    w_register_font Arial.TTF "Arial (TrueType)"
    w_register_font Arialbd.TTF "Arial Bold (TrueType)"
    w_register_font Arialbi.TTF "Arial Bold Italic (TrueType)"
    w_register_font Ariali.TTF "Arial Italic (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/arialb32.exe
    w_try cp -f "$W_TMP"/AriBlk.TTF "$W_FONTSDIR_UNIX"
    w_register_font AriBlk.TTF "Arial Black (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/comic32.exe
    w_try cp -f "$W_TMP"/Comic*.TTF "$W_FONTSDIR_UNIX"
    w_register_font Comic.TTF "Comic Sans MS (TrueType)"
    w_register_font Comicbd.TTF "Comic Sans MS Bold (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/courie32.exe
    w_try cp -f "$W_TMP"/cour*.ttf "$W_FONTSDIR_UNIX"
    w_register_font Cour.TTF "Courier New (TrueType)"
    w_register_font CourBD.TTF "Courier New Bold (TrueType)"
    w_register_font CourBI.TTF "Courier New Bold Italic (TrueType)"
    w_register_font Couri.TTF "Courier New Italic (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/georgi32.exe
    w_try cp -f "$W_TMP"/Georgia*.TTF "$W_FONTSDIR_UNIX"
    w_register_font Georgia.TTF "Georgia (TrueType)"
    w_register_font Georgiab.TTF "Georgia Bold (TrueType)"
    w_register_font Georgiaz.TTF "Georgia Bold Italic (TrueType)"
    w_register_font Georgiai.TTF "Georgia Italic (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/impact32.exe
    w_try cp -f "$W_TMP"/Impact.TTF "$W_FONTSDIR_UNIX"
    w_register_font Impact.TTF "Impact (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/times32.exe
    w_try cp -f "$W_TMP"/Times*.TTF "$W_FONTSDIR_UNIX"
    w_register_font Times.TTF "Times New Roman (TrueType)"
    w_register_font Timesbd.TTF "Times New Roman Bold (TrueType)"
    w_register_font Timesbi.TTF "Times New Roman Bold Italic (TrueType)"
    w_register_font Timesi.TTF "Times New Roman Italic (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/trebuc32.exe
    w_try cp -f "$W_TMP"/trebuc*.ttf "$W_FONTSDIR_UNIX"
    w_register_font Trebuc.TTF "Trebucet MS (TrueType)"
    w_register_font Trebucbd.TTF "Trebucet MS Bold (TrueType)"
    w_register_font Trebucbi.TTF "Trebucet MS Bold Italic (TrueType)"
    w_register_font Trebucit.TTF "Trebucet MS Italic (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/verdan32.exe
    w_try cp -f "$W_TMP"/Verdana*.TTF "$W_FONTSDIR_UNIX"
    w_register_font Verdana.TTF "Verdana (TrueType)"
    w_register_font Verdanab.TTF "Verdana Bold (TrueType)"
    w_register_font Verdanaz.TTF "Verdana Bold Italic (TrueType)"
    w_register_font Verdanai.TTF "Verdana Italic (TrueType)"

    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/corefonts/webdin32.exe
    w_try cp -f "$W_TMP"/Webdings.TTF "$W_FONTSDIR_UNIX"
    w_register_font Webdings.TTF "Webdings (TrueType)"
}

#----------------------------------------------------------------

w_metadata droid fonts \
   title="Droid fonts (on LCD, looks better with fontsmooth-rgb)" \
   publisher="Ascender Corporation" \
   year="2009" \
   media="download" \
   file1="DroidSans-Bold.ttf" \
   installed_file1="$W_FONTSDIR_WIN"\\DroidSans-Bold.ttf

do_droid() {
    w_download droid ${DROID_URL}$1';hb=HEAD'   $3  $1
    w_try cp -f "$W_CACHE"/droid/$1 "$W_FONTSDIR_UNIX"
    w_register_font $1 "$2"
}

load_droid()
{
    # See http://en.wikipedia.org/wiki/Droid_(font)
    DROID_URL='http://android.git.kernel.org/?p=platform/frameworks/base.git;a=blob_plain;f=data/fonts/'

    do_droid DroidSans-Bold.ttf        "Droid Sans Bold"         ada4e79c592f3c54546b7587b48f2b232d95ce2f
    do_droid DroidSansFallback.ttf     "Droid Sans Fallback"     5065cce92e8420232db95ab3ba421e462b09b965
    do_droid DroidSansJapanese.ttf     "Droid Sans Japanese"     b3a248c11692aa88a30eb25df425b8910fe05dc5
    do_droid DroidSansMono.ttf         "Droid Sans Mono"         f0815c6f36c72be1d0f2f5e2b82fa85c8bf95655
    do_droid DroidSans.ttf             "Droid Sans"              da5b3c7758a2c8fbc4775beb69d7150493c7d312
    do_droid DroidSerif-BoldItalic.ttf "Droid Serif Bold Italic" c1602dc11bf0f7131aec21c7c3888195ad78e486
    do_droid DroidSerif-Bold.ttf       "Droid Serif Bold"        d7896b9c0723299553e95a00d27cbe52f7515c8c
    do_droid DroidSerif-Italic.ttf     "Droid Serif Italic"      117941be102c8f38a86a70ebccaecb8078f7027e
    do_droid DroidSerif-Regular.ttf    "Droid Serif"             7f243858e496ed1bb1faca9f3a7bbe52defcbb5d
}

#----------------------------------------------------------------

w_metadata eufonts fonts \
   title="Updated fonts for Romanian and Bulgarian" \
   publisher="Microsoft" \
   year="2008" \
   media="download" \
   file1="EUupdate.EXE" \
   installed_file1="$W_FONTSDIR_WIN"\\trebucbd.ttf

load_eufonts()
{
    # https://www.microsoft.com/downloads/details.aspx?FamilyID=0ec6f335-c3de-44c5-a13d-a1e7cea5ddea&displaylang=en
    w_download eufonts http://download.microsoft.com/download/a/1/8/a180e21e-9c2b-4b54-9c32-bf7fd7429970/EUupdate.EXE 9b076c40cb63aa0d8512aa8e610ba11d3466e441
    w_try_cabextract -q --directory="$W_TMP" "$W_CACHE"/eufonts/EUupdate.EXE
    w_try cp -f "$W_TMP"/*.ttf "$W_FONTSDIR_UNIX"

    w_register_font ArialBI.ttf "Arial Bold Italic (TrueType)"
    w_register_font ArialI.ttf "Arial Italic (TrueType)"
    w_register_font Arial.ttf "Arial (TrueType)"
    w_register_font TimesBd.ttf "Times New Roman Bold (TrueType)"
    w_register_font TimesBI.ttf "Times New Roman Bold Italic (TrueType)"
    w_register_font TimesI.ttf "Times New Roman Italic (TrueType)"
    w_register_font Times.ttf "Times New Roman (TrueType)"
    w_register_font trebucbd.ttf "Trebuchet Bold (TrueType)"
    w_register_font trebucbi.ttf "Trebuchet Bold Italic (TrueType)"
    w_register_font trebucit.ttf "Trebuchet Italic (TrueType)"
    w_register_font trebuc.ttf "Trebuchet (TrueType)"
    w_register_font Verdanab.ttf "Verdana Bold (TrueType)"
    w_register_font Verdanai.ttf "Verdana Italian (TrueType)"
    w_register_font Verdana.ttf "Verdana (TrueType)"
    w_register_font Verdanaz.ttf "Verdana Bold Italic (TrueType)"
}

#----------------------------------------------------------------

w_metadata fakechinese fonts \
   title="Creates aliases for Chinese fonts using WenQuanYi fonts" \
   publisher="wenq.org" \
   year="2009"

load_fakechinese()
{
    w_try w_call wenquanyi
    # Loads Wenquanyi fonts and sets aliases for Microsoft Chinese fonts
    # Aliases to set:
    # Microsoft JhengHei --> WenQuanYi Micro Hei
    # Microsoft YaHei --> WenQuanYi Micro Hei
    # SimHei --> WenQuanYi Micro Hei

    w_register_font_substitution "Microsoft JhengHei" "WenQuanYi Micro Hei"
    w_register_font_substitution "Microsoft YaHei" "WenQuanYi Micro Hei"
    w_register_font_substitution "SimHei" "WenQuanYi Micro Hei"
}

#----------------------------------------------------------------

w_metadata fakejapanese fonts \
   title="Creates aliases for Japanese fonts using Takao fonts"
   publisher="Jun Kobayashi" \
   year="2010"

load_fakejapanese()
{
    w_try w_call takao
    # Loads Takao fonts and sets aliases for MS Gothic and MS PGothic, mainly for Japanese language support
    # Aliases to set:
    # MS Gothic --> TakaoGothic
    # MS PGothic --> TakaoPGothic
    # MS Mincho --> TakaoMincho
    # MS PMincho --> TakaoPMincho
    # These aliases were taken from what was listed in Ubuntu's fontconfig definitions.

    w_register_font_substitution "MS Gothic" "TakaoGothic"
    w_register_font_substitution "MS PGothic" "TakaoPGothic"
    w_register_font_substitution "MS Mincho" "TakaoMincho"
    w_register_font_substitution "MS PMincho" "TakaoPMincho"
}

#----------------------------------------------------------------

w_metadata fakekorean fonts \
   title="Creates aliases for Korean fonts using Baekmuk fonts" \
   publisher="Wooderart Inc. / kldp.net" \
   year="1999"

load_fakekorean()
{
    w_try w_call baekmuk
    # Loads Baekmuk fonts and sets as an alias for Gulim, Dotum, and Batang for Korean language support
    # Aliases to set:
    # Gulim --> Baekmuk Gulim
    # GulimChe --> Baekmuk Gulim
    # Batang --> Baekmuk Batang
    # BatangChe --> Baekmuk Batang
    # Dotum --> Baekmuk Dotum
    # DotumChe --> Baekmuk Dotum

    w_register_font_substitution "Gulim" "Baekmuk Gulim"
    w_register_font_substitution "GulimChe" "Baekmuk Gulim"
    w_register_font_substitution "Batang" "Baekmuk Batang"
    w_register_font_substitution "BatangChe" "Baekmuk Batang"
    w_register_font_substitution "Dotum" "Baekmuk Dotum"
    w_register_font_substitution "DotumChe" "Baekmuk Dotum"
}

#----------------------------------------------------------------

w_metadata lucida fonts \
   title="MS Lucida Console font" \
   publisher="Microsoft" \
   year="1998" \
   media="download" \
   file1="eurofixi.exe" \
   installed_file1="$W_FONTSDIR_WIN"\\lucon.ttf

load_lucida()
{
    w_download lucida ftp://ftp.microsoft.com/bussys/winnt/winnt-public/fixes/usa/NT40TSE/hotfixes-postSP3/Euro-fix/eurofixi.exe 64c47ad92265f6f10b0fd909a703d4fd1b05b2d5
    w_try_cabextract -d "$W_FONTSDIR_UNIX" -L -F 'lucon.ttf' "$W_CACHE"/lucida/eurofixi.exe
    w_register_font lucon.ttf "Lucida Console" 
}

#----------------------------------------------------------------

w_metadata takao fonts \
   title="Takao Japanese fonts" \
   publisher="Jun Kobayashi" \
   year="2010" \
   media="download" \
   file1="takao-fonts-ttf-003.02.01.zip" \
   installed_file1="$W_FONTSDIR_WIN"\\TakaoGothic.ttf

load_takao()
{
    # The Takao font provides Japanese glyphs.  May also be needed with fakejapanese function above.
    # See http://launchpad.net/takao-fonts for project page
    w_download takao http://launchpad.net/takao-fonts/003.02/003.02.01/+download/takao-fonts-ttf-003.02.01.zip 4f636d5c7c1bc16b96ea723adb16838cfb6df059
    cp -f "$W_CACHE"/takao/takao-fonts-ttf-003.02.01.zip "$W_TMP"
    w_try unzip -d "$W_TMP" "$W_TMP"/takao-fonts-ttf-003.02.01.zip
    w_try cp -f "$W_TMP"/takao-fonts-ttf-003.02.01/*.ttf "$W_FONTSDIR_UNIX"

    w_register_font TakaoGothic.ttf "TakaoGothic"
    w_register_font TakaoPGothic.ttf "TakaoPGothic"
    w_register_font TakaoMincho.ttf "TakaoMincho"
    w_register_font TakaoPMincho.ttf "TakaoPMincho"
    w_register_font TakaoExGothic.ttf "TakaoExGothic"
    w_register_font TakaoExMincho.ttf "TakaoExMincho"
}

#----------------------------------------------------------------

w_metadata wenquanyi fonts \
   title="WenQuanYi CJK font (on LCD looks better with fontsmooth-rgb)" \
   publisher="wenq.org" \
   year="2009" \
   media="download" \
   file1="wqy-microhei-0.2.0-beta.tar.gz" \
   installed_file1="$W_FONTSDIR_WIN"\\wqy-microhei.ttc

load_wenquanyi()
{
    # See http://wenq.org/enindex.cgi
    # Donate at http://wenq.org/enindex.cgi?Download(en)#MicroHei_Beta if you want to help support free CJK font development
    w_download wenquanyi $WISOTOOL_SOURCEFORGE/wqy/wqy-microhei-0.2.0-beta.tar.gz 28023041b22b6368bcfae076de68109b81e77976
    cd "$W_TMP/"
    gunzip -dc "$W_CACHE/wenquanyi/wqy-microhei-0.2.0-beta.tar.gz" | tar -xf -
    w_try mv wqy-microhei/wqy-microhei.ttc "$W_FONTSDIR_UNIX"
    w_register_font wqy-microhei.ttc "WenQuanYi Micro Hei"
}

#----------------------------------------------------------------

w_metadata unifont fonts \
   title="Unifont alternative to Arial Unicode MS" \
   publisher="GNU" \
   year="2008" \
   media="download" \
   file1="unifont-5.1.20080907.zip" \
   installed_file1="$W_FONTSDIR_WIN"\\unifont.ttf

load_unifont()
{
    # The GNU Unifont provides glyphs for just about everything in common language.  It is intended for multilingual usage.
    # See http://unifoundry.com/unifont.html for project page
    w_download unifont http://unifoundry.com/unifont-5.1.20080907.zip bb8a3960dc0a96aa305de28312ea8a0ab64123d2
    cp -f "$W_CACHE"/unifont/unifont-5.1.20080907.zip "$W_TMP"
    w_try unzip -d "$W_TMP" "$W_TMP"/unifont-5.1.20080907.zip
    w_try cp -f "$W_TMP"/unifont-5.1.20080907.ttf "$W_FONTSDIR_UNIX/unifont.ttf"

    w_register_font unifont.ttf "Unifont"
    w_register_font_substitution "Arial Unicode MS" "Unifont"
}


#----------------------------------------------------------------
# Apps
#----------------------------------------------------------------

w_metadata 7zip apps \
   title="7-Zip" \
   publisher="Igor Pavolv" \
   year="1999" \
   media="download" \
   file1="7z465.exe" \
   installed_exe1="$W_PROGRAMS_X86_WIN\\7-Zip\\7z.exe"

load_7zip()
{
    # FIXME: use more up to date version
    w_download 7zip http://downloads.sourceforge.net/sevenzip/7z465.exe c36012e960fa3932cd23f30ac5b0fe722740243a
    cd "$W_CACHE"/7zip
    w_try $WINE 7z465.exe $W_UNATTENDED_SLASH_S
    w_declare_exe "$W_PROGRAMS_X86_WIN\\7-Zip" "7z.exe %1 %2 %3 %4 %5"
}

#----------------------------------------------------------------

w_metadata  abiword apps \
   title="AbiWord 2.8.6" \
   publisher="AbiSource" \
   year="2010" \
   media="download" \
   file1="abiword-setup-2.8.6.exe" \
   installed_exe1="$W_PROGRAMS_X86_WIN\\AbiWord\\bin\\AbiWord.exe"

load_abiword()
{
    w_download abiword http://www.abisource.com/downloads/abiword/2.8.6/Windows/abiword-setup-2.8.6.exe a91acd3f60e842d23556032d34f1600602768318
    cd "$W_CACHE"/abiword
    w_try $WINE abiword-setup-2.8.6.exe $W_UNATTENDED_SLASH_S
    w_declare_exe "$W_PROGRAMS_X86_WIN\\AbiWord\\bin" AbiWord.exe
}

#----------------------------------------------------------------

w_metadata autohotkey apps \
   title="Autohotkey" \
   publisher="autohotkey.org" \
   year="2010" \
   media="download" \
   file1="AutoHotkey104805_Install.exe" \
   installed_exe1="$W_PROGRAMS_X86_WIN\\AutoHotkey\\AutoHotkey.exe"

load_autohotkey()
{
    w_download autohotkey http://www.autohotkey.net/programs/AutoHotkey104805_Install.exe 13e5a9ca6d5b7705f1cd02560c3af4d38b1904fc
    cd "$W_CACHE"/autohotkey
    w_try $WINE AutoHotkey104805_Install.exe $W_UNATTENDED_SLASH_S
}

#----------------------------------------------------------------

w_metadata mspaint apps \
   title="MS Paint" \
   publisher="Microsoft" \
   year="2001" \
   media="download" \
   file1="paintnt.exe" \
   installed_exe1="c:\\windows\\mspaint.exe"

load_mspaint()
{
    # http://helpforlinux.blogspot.com/2008/12/run-ms-paint-in-linux.html
    w_download mspaint http://download.microsoft.com/download/winntwks40/paint/1/nt4/en-us/paintnt.exe a22c4e367ef9d2cd23f0a8ae8d9ebff5bc1e8a0b
    w_try unzip "$W_CACHE"/mspaint/paintnt.exe -d "$W_WINDIR_UNIX"

    w_declare_exe "$W_WINDIR_UNIX" "mspaint.exe"
}

#----------------------------------------------------------------

w_metadata  safari apps \
   title="Safari" \
   publisher="Apple" \
   year="2010" \
   media="download" \
   file1="SafariSetup.exe" \
   installed_exe1="$W_PROGRAMS_X86_WIN\\Safari\\Safari.exe"

load_safari()
{
    w_download safari http://appldnld.apple.com.edgesuite.net/content.info.apple.com/Safari5/061-7138.20100607.Y7U87/SafariSetup.exe e56d5d79d9cfbb85ac46ac78aa497d7f3d8dbc3d

    cd "$W_CACHE"/$W_PACKAGE

    if w_workaround_wine_bug 21146
    then
        w_try mkdir -p "$W_APPDATA_UNIX/Apple Computer/Preferences"
        cat > "$W_APPDATA_UNIX/Apple Computer/Preferences/com.apple.Safari.plist" <<_EOF_
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
        <key>LastDisplayedWelcomePageVersionString</key>
        <string>4.0</string>
</dict>
</plist>
_EOF_
    fi

    if test $W_OPT_UNATTENDED = 1
    then
        w_warn "Safari's silent install is broken under wine. See http://bugs.winehq.org/show_bug.cgi?id=23493. You should do a regular install if you want to use Safari."
        w_try $WINE SafariSetup.exe /qn
    else
        w_try $WINE SafariSetup.exe
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Safari" "Safari.exe"
}

#----------------------------------------------------------------
# Benchmarks
#----------------------------------------------------------------

w_metadata 3dmark2000 benchmarks \
    title="3DMark2000" \
    publisher="MadOnion.com" \
    year="2000" \
    media="download" \
    file1="3dmark2000_v11_100308.exe" \
    installed_file1="$W_PROGRAMS_X86_WIN\\MadOnion.com\\3DMark2000\\3DMark2000.exe"

load_3dmark2000()
{
    # http://www.futuremark.com/download/3dmark2000/
    if ! test -f "$W_CACHE/$W_PACKAGE/3dmark2000_v11_100308.exe"
    then
        w_download $W_PACKAGE http://www.ocinside.de/download/3dmark2000_v11_100308.exe b0400d59cfd45d8c8893d3d4edc58b6285ee1502
    fi

    cd "$W_TMP"
    mkdir $W_PACKAGE
    cd $W_PACKAGE
    w_try unzip "$W_CACHE/$W_PACKAGE"/3dmark2000_v11_100308.exe
    w_ahk_do "
        SetTitleMatchMode, 2
        run Setup.exe
        WinWait Welcome
        ControlClick Button1  ; Next
        WinWait License
        ControlClick Button2  ; Yes
        ;WinWaitClose ahk_class #32770 ; License
        WinWait ahk_class #32770, Destination
        ControlClick Button1  ; Next
        ;WinWaitClose ahk_class #32770 ; Destination
        WinWait, Start
        ControlClick Button1  ; Next
        WinWait Registration
        ControlClick Button1  ; Next
        WinWait Complete
        ControlClick Button1  ; Unclick View Readme
        ControlClick Button4  ; Finish
    "

    cat > "$W_DRIVE_C/run-$W_PACKAGE.bat" <<__EOF__
${programfilesdrive}:
cd "$W_PROGRAMS_X86_WIN\MadOnion.com\3DMark2000"
REM possible wine cmd bug: "3dmark2000" aborts, but ".\3dmark2000" works
.\3DMark2000
__EOF__

}

#----------------------------------------------------------------
# Games
#----------------------------------------------------------------

w_metadata  bfbc2 games \
   title="Battlefield Bad Company 2" \
   publisher="EA" \
   year="2010" \
   media="dvd" \
   file1="BFBC2.iso"

load_bfbc2()
{
    w_mount BFBC2
    w_read_key
    w_ahk_do "
        SetTitleMatchMode, 2
        run ${W_ISO_MOUNT_LETTER}:setup.exe
        winwait, Bad Company, English
        ControlClick, Next, Bad Company
        winwait, Bad Company, Registration Code
        send {RAW}$W_KEY
        ControlClick, Next, Bad Company, Registration Code
        winwait, Bad Company, Setup Wizard will install
        ControlClick, Button1, Bad Company, Setup Wizard
        winwait, Bad Company, License Agreement
        ControlClick, Button1, Bad Company, License Agreement
        ControlClick, Button3, Bad Company, License Agreement
        winwait, Bad Company, End-User License Agreement
        ControlClick, Button1, Bad Company, License Agreement
        ControlClick, Button3, Bad Company, License Agreement
        winwait, Bad Company, Destination Folder
        ControlClick, Button1, Bad Company, Destination Folder
        winwait, Bad Company, Ready to install
        ControlClick, Install, Bad Company, Ready to install
        winwait, Authenticate Battlefield
        ControlClick, Disc authentication, Authenticate Battlefield
        ControlClick, Button4, Authenticate Battlefield
        winwait, Bad Company, PunkBuster
        ControlClick, Button4, Bad Company, PunkBuster
        ControlClick, Finish, Bad Company
    "

    w_warn "Patching to latest version..."

    cd "$W_PROGRAMS_X86_UNIX/Electronic Arts/Battlefield Bad Company 2"
    w_ahk_do "
        SetTitleMatchMode, 2
        run, BFBC2Updater.exe
        winwait, Updater, have to update to
        ControlClick, Yes, Updater, have to update
        winwait, Updater, successfully updated
        ControlClick,No, Updater, successfully updated
    "

    if w_workaround_wine_bug 22762
    then
        # FIXME: does this directory name change in win7?
        cd "$W_DRIVE_C/users/$USERNAME/My Documents"
        if test -f BFBC2/settings.ini
        then
            mv BFBC2/settings.ini BFBC2/oldsettings.ini
            sed 's,DxVersion=auto,DxVersion=9,;
                 s,Fullscreen=true,Fullscreen=false,' BFBC2/oldsettings.ini > BFBC2/settings.ini
        else
            mkdir -p BFBC2
            echo "[Graphics]" > BFBC2/settings.ini
            echo "DxVersion=9" >> BFBC2/settings.ini
        fi
    fi

    if w_workaround_wine_bug 22961
    then
        w_warn 'If the game says "No CD/DVD error", try "sudo mount -o remount,unhide,uid=`uid -u`".  See http://bugs.winehq.org/show_bug.cgi?id=22961 for more info.'
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Electronic Arts\\Battlefield Bad Company 2" "BFBC2Game.exe"
}

#----------------------------------------------------------------

# http://appdb.winehq.org/objectManager.php?sClass=version&iId=9320
w_metadata  blobby_volley games \
   title="Blobby Volley" \
   publisher="Daniel Skoraszewsky" \
   year="2000" \
   media="manual_download" \
   file1="blobby.zip" \
   installed_exe1="c:\\BlobbyVolley\\volley.exe"

load_blobby_volley()
{
    w_download_manual blobby_volley http://www.chip.de/downloads/Blobby-Volley_12990993.html blobby.zip c7057c77a5009a88d9d877e17a63b5536ebeb177

    mkdir -p "$W_DRIVE_C/BlobbyVolley"
    cd "$W_CACHE/$W_PACKAGE"
    w_try unzip blobby.zip -d "$W_DRIVE_C/BlobbyVolley"
    w_declare_exe "c:\\BlobbyVolley" "volley.exe"

    if w_workaround_wine_bug 4432
    then
        w_warn "You may need to apply a patch, see http://bugs.winehq.org/show_bug.cgi?id=4432#c15"
    fi
}

#----------------------------------------------------------------

w_metadata civ4_demo games \
   title="Civilization IV Demo" \
   publisher="Firaxis Games" \
   year="2005" \
   media="manual_download" \
   file1="Civilization4_Demo.zip" \
   installed_file1="$W_PROGRAMS_X86_WIN\\Firaxis Games\\Sid Meier's Civilization 4 Demo\\Civilization4.exe"

load_civ4_demo()
{
    w_download_manual civ4_demo http://download.cnet.com/Civilization-IV-demo/3000-7489_4-10465206.html Civilization4_Demo.zip b54f1e5d0a1c2d1ef456d0c20098c23bbb6a0ea7

    cd "$W_CACHE/$W_PACKAGE"
    w_try unzip Civilization4_Demo.zip -d "$W_TMP"
    cd "$W_TMP/$W_PACKAGE"
    chmod +x setup.exe
    w_ahk_do "
        SetTitleMatchMode, 2
        run, setup.exe
        winwait, Choose Setup Language
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            Send {enter}
            winwait, Civilization 4, Welcome
            ControlClick &Next >, Civilization 4
            winwait, Civilization 4, I &accept the terms of the license agreement
            ControlClick I &accept, Civilization 4
            ControlClick &Next >, Civilization 4
            winwait, Civilization 4, Express Install
            ControlClick &Next >, Civilization 4
            winwait, Civilization 4, begin installation
            ControlClick &Install, Civilization 4
            winwait, Civilization 4, InstallShield Wizard Complete
            ControlClick Finish, Civilization 4
        }
        winwaitclose
    "

    if w_workaround_wine_bug 6856
    then
        w_try_winetricks msxml3
    fi
    if w_workaround_wine_bug 6856 # part 2, still need to file a bug
    then
        w_try_winetricks d3dx9_26
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Firaxis Games\\Sid Meier's Civilization 4 Demo" "Civilization4.exe"
}

#----------------------------------------------------------------

w_metadata  lemonysnicket games \
   title="Lemony Snicket's A Series of Unfortunate Events" \
   publisher="Activision" \
   year="2004" \
   media="cd" \
   file1="Lemony Snicket.iso"

load_lemonysnicket()
{
    w_mount "Lemony Snicket"
    w_ahk_do "
        SetTitleMatchMode, 2
        Run, ${W_ISO_MOUNT_LETTER}:setup.exe
        WinWait, Lemony, Welcome
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            ControlClick, Button1 ; Next
            WinWait, Lemony, License
            sleep 1000
            ControlClick, Button2 ; Accept
            WinWait, Lemony, Minimum System
            sleep 1000
            ControlClick, Button2 ; Yes
            WinWait, Lemony, Destination
            sleep 1000
            ControlClick, Button1 ; Next
            WinWait, Lemony, Select Program Folder
            sleep 1000
            ControlClick, Button2 ; Next
            WinWait, Lemony, Start Copying
            sleep 1000
            ControlClick, Button1 ; Next
            WinWait, Question, Would you like to add a desktop shortcut
            sleep 1000
            ControlClick, Button2 ; No
            WinWait, Question, Would you like to register
            sleep 1000
            ControlClick, Button2 ; No
            ;WinWait, Information, Please register
            ;sleep 1000
            ;ControlClick, Button1 ; OK
            WinWait, Lemony, Complete
            sleep 1000
            ControlClick, Button4 ; Finish
            WinWait, Lemony, Play
            sleep 1000
            ControlClick, Button6 ; Exit
            WinWait, Lemony, Are you sure
            sleep 1000
            ControlClick, Button1 ; Yes already
        }
        WinWaitClose, Lemony
    "

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Activision\\Lemony Snicket's A Series of Unfortunate Events" System\\game.exe
}

#----------------------------------------------------------------

w_metadata masseffect2 games \
    title="Mass Effect 2" \
    publisher="BioWare" \
    year="2010" \
    media="dvd" \
    file1="MassEffect2.iso" \
    file2="ME2_Disc2.iso" 

load_masseffect2()
{
    w_mount MassEffect2
    w_read_key

    if w_workaround_wine_bug 22091
    then
        w_warn "Will probably hang at end of installer.  If a crash dialog comes up, you can kill it, it's done."
        w_try_winetricks nocrashdialog
    fi

    if w_workaround_wine_bug 23126 "wine-1.3.[0-9]*"
    then
        w_try_winetricks vcrun2005
    fi
    if w_workaround_wine_bug 23125 "wine-1.3.[0-9]*"
    then
        w_try_winetricks d3dx10
    fi
    if w_workaround_wine_bug 23151
    then
        w_warn "Disabling glsl to workaround wine bug 23151. Users of nvidia cards will get weird effects without this. If you're on ATI/Intel, you can revert this with 'winetricks glsl-enable'"
        w_try_winetricks glsl-disable
    fi
    if w_workaround_wine_bug 22919
    then
        w_try_winetricks physx
    fi

    w_ahk_do "
        SetTitleMatchMode, 2
        run, ${W_ISO_MOUNT_LETTER}:Setup.exe
        winwait, Installer Language
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            send {Enter}
            winwait, Mass Effect
            send {Enter}
            winwait, Mass Effect, License
            ControlClick, Button4
            ControlClick, Button2
            winwait, Mass Effect, Registration Code
            send $W_KEY
            ControlClick, Button2
            winwait, Mass Effect, Install Type
            ControlClick, Button2
        }
        winwait, Insert Disc
    "
    sleep 5
    w_mount ME2_Disc2
    w_ahk_do "
        SetTitleMatchMode, 2
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            winwait, Insert Disc
            ControlClick, Button4
            ; on windows, the first click doesn't seem to do it, so press enter, too
            sleep 1000
            send {Enter}
        }
        ; Some installs may not get to this point due to an installer hang/crash (bug 22919)
        ; The hang/crash happens after the Physx install but does not seem to affect gameplay
        loop
        {
            ifwinexist, Mass Effect, Finish
            {
                if ( u > 0 ) {
                    winkill, Mass Effect
                }
                break
            }
            Process, exist, Installer.exe
            me2pid = %ErrorLevel%
            if me2pid = 0
                break
            sleep 1000
        }
    "
    if w_workaround_wine_bug 6971
    then
        w_warn "See http://appdb.winehq.org/objectManager.php?sClass=version&iId=19125 for info on how to patch wine to work around bug 6971"
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Mass Effect 2\\Binaries" "MassEffect2.EXE"
}

#----------------------------------------------------------------

w_metadata menofwar games \
    title="Men of War" \
    publisher="Aspyr Media" \
    year="2009" \
    media="dvd" \
    file1="Men of War.iso" \
    installed_exe1="$W_PROGRAMS_X86_WIN\\Aspyr\\Men of War\\mow.exe"

load_menofwar()
{
    w_mount "Men of War"

    cd "$W_ISO_MOUNT_ROOT"
    w_ahk_do "
        SetTitleMatchMode, 2
        SetTitleMatchMode, slow
        run ${W_ISO_MOUNT_LETTER}:setup.exe
        winwait, Select Setup Language, Select the language
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            ControlClick, TNewButton1, Select Setup Language, Select the language
            winwait, Men of War
            sleep 1000
            ControlClick, TButton4, Men of War
            winwait, Setup - Men of War, ACCEPTANCE OF AGREEMENT
            sleep 1000
            ControlClick, TNewRadioButton1, Setup - Men of War, ACCEPTANCE OF AGREEMENT
            ControlClick, TNewButton1, Setup - Men of War, ACCEPTANCE OF AGREEMENT
        }
        winwait, Setup - Men of War, Setup has finished installing
        if ( u > 0 ) {
            sleep 1000
            ControlClick, x242 y254
            ControlClick, x242 y278
            ControlClick, TNewButton1, Setup - Men of War, Setup has finished
        }
    "

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Aspyr\\Men of War" "mow.exe"
}

#----------------------------------------------------------------

w_metadata singularity games \
    title="Singularity" \
    publisher="Activision" \
    year="2010" \
    media="dvd" \
    file1="SNG_DVD.iso"

load_singularity()
{
    w_read_key
    w_mount SNG_DVD

    w_ahk_do "
        run ${W_ISO_MOUNT_LETTER}:setup.exe
        winwait, Activision(R) - InstallShield, Select the language for the installation from the choices below.
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            controlclick, Button1, Activision(R) - InstallShield, Select the language for the installation from the choices below.
            sleep 1000
            winwait, Singularity(TM), Keycode Check
            sleep 1000
            Send $W_KEY
            sleep 1000
            Send {Enter}
            ; Well this is annoying...
            Winwait, Keycode Check, The Keycode you entered appears to be valid.
            sleep 1000
            Send {Enter}
            winwait, Singularity(TM), The InstallShield Wizard will install Singularity(TM) on your computer
            sleep 1000
            controlclick, Button1, Singularity(TM), The InstallShield Wizard will install Singularity(TM) on your computer
            winwait, Singularity(TM), Please read the following license agreement carefully
            sleep 1000
            controlclick, Button5, Singularity(TM), Please read the following license agreement carefully
            sleep 1000
            controlclick, Button2, Singularity(TM), Please read the following license agreement carefully
            winwait, Singularity(TM), Minimum System Requirements
            sleep 1000
            controlclick, Button1, Singularity(TM), Minimum System Requirements
            winwait, Singularity(TM), Select the setup type to install
            controlclick, Button4, Singularity(TM), Select the setup type to install
        }
        ; Loop until installer window has been gone for at least two seconds
        Loop
        {
            sleep 1000
            IfWinExist, Singularity
                continue
            IfWinExist, Activision
                continue
            sleep 1000
            IfWinExist, Singularity
                continue
            IfWinExist, Activision
                continue
            break
        }
        "

    if w_workaround_wine_bug 6971
    then
        w_try_winetricks mwo=force
    fi

    if w_workaround_wine_bug 22548
    then
        echo "Disabling \'depth of field\'"
        cat > "$W_TMP"/dof.reg <<_EOF_
REGEDIT4

[HKEY_CURRENT_USER\Software\Activision\Singularity]
"DepthOfField"=dword:00000000

_EOF_
        w_try_regedit "$W_TMP_WIN"\\dof.reg
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Activision\\Singularity(TM)\\Binaries" "Singularity.exe"

    # Clean up crap left over in c:\ when the installer runs the vc 2008 redistributable installer
    cd "$W_DRIVE_C"
    rm -f VC_RED.* eula.*.txt globdata.ini install.exe install.ini install.res.*.dll vcredist.bmp
}

#----------------------------------------------------------------

w_metadata  torchlight games \
   title="Torchlight - boxed version" \
   publisher="Runic Games" \
   year="2009" \
   media="dvd" \
   file1="Torchlight.iso"

load_torchlight()
{
    w_mount "Torchlight"
    w_ahk_do "
        SetTitleMatchMode, 2
        Run, ${W_ISO_MOUNT_LETTER}:Torchlight.exe
        WinWait, Torchlight Setup, This wizard will guide
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            ControlClick, Button2, Torchlight Setup, This wizard will guide
            WinWait, Torchlight Setup, Please review the license terms
            sleep 1000
            ControlClick, Button2, Torchlight Setup, Please review the license terms
            WinWait, Torchlight Setup, Choose Install Location
            sleep 1000
            ControlClick, Button2, Torchlight Setup, Choose Install Location
            WinWait, Torchlight Setup, Installation Complete
            sleep 1000
            ControlClick, Button2, Torchlight Setup, Installation Complete
            WinWait, Torchlight Setup, Completing the Torchlight Setup Wizard
            sleep 1000
            ControlClick, Button4, Torchlight Setup, Completing the Torchlight Setup Wizard
            ControlClick, Button2, Torchlight Setup, Completing the Torchlight Setup Wizard
        }
        WinWaitClose, Torchlight Setup
    "

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Runic Games\\Torchlight" Torchlight.exe
}

#----------------------------------------------------------------

w_metadata  twfc games \
    title="Transformers: War for Cybertron" \
    publisher="Activision" \
    year="2010" \
    media="dvd" \
    file1="TWFC_DVD.iso"

load_twfc()
{
    w_read_key
    w_mount TWFC_DVD

    w_ahk_do "
        run ${W_ISO_MOUNT_LETTER}:setup.exe
        SetTitleMatchMode, 2
        winwait, Activision, Select the language for the installation
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            controlclick, Button1, Activision, Select the language for the installation
            winwait, Transformers, Press NEXT to verify your key
            sleep 1000
            send $W_KEY
            send {Enter}
            winwait, Keycode Check, The Keycode you entered appears to be valid
            sleep 1000
            send {Enter}
            winwait, Transformers, The InstallShield Wizard will install Transformers
            sleep 1000
            controlclick, Button1, Transformers, The InstallShield Wizard will install Transformers
            winwait, Transformers, License Agreement
            sleep 1000
            controlclick, Button5, Transformers, License Agreement
            sleep 1000
            controlclick, Button2, Transformers, License Agreement
            winwait, Transformers, Minimum System Requirements
            sleep 1000
            controlclick, Button1, Transformers, Minimum System Requirements
            winwait, Transformers, Select the setup type to install
            sleep 1000
            controlclick, Button4, Transformers, Select the setup type to install
        }
        ; Installer exits silently. Prevent an early umount
        Loop
        {
            sleep 1000
            IfWinExist, Transformers
                continue
            IfWinExist, Activision
                continue
            sleep 1000
            IfWinExist, Transformers
                continue
            IfWinExist, Activision
                continue
            break
        }
    "

    if w_workaround_wine_bug 6971
    then
        w_try_winetricks mwo=force
    fi

    w_declare_exe "$W_PROGRAMS_X86_WIN\\Activision\\Transformers - War for Cybertron\\Binaries" "TWFC.exe"

    # Clean up crap left over in c:\ when the installer runs the vc 2008 redistributable installer
    cd "$W_DRIVE_C"
    rm -f VC_RED.* eula.*.txt globdata.ini install.exe install.ini install.res.*.dll vcredist.bmp
}

#----------------------------------------------------------------

w_metadata  wog games \
    title="World of Goo Demo" \
    publisher="2D Boy" \
    year="2008" \
    media="download" \
    file1="WorldOfGooDemo.1.0.exe" \
    installed_exe1="$W_PROGRAMS_X86_WIN\\WorldOfGooDemo\\WorldOfGoo.exe"

load_wog()
{
    if ! test -f "$W_CACHE/wog/WorldOfGooDemo.1.0.exe"
    then
        # Get temporary download location
        w_download wog "http://www.worldofgoo.com/dl2.php?lk=demo&filename=WorldOfGooDemo.1.0.exe"
        URL=`cat "$W_CACHE/wog/dl2.php?lk=demo&filename=WorldOfGooDemo.1.0.exe" |
           grep WorldOfGooDemo.1.0.exe | sed 's,.*http,http,;s,".*,,'`
        rm "$W_CACHE/wog/dl2.php?lk=demo&filename=WorldOfGooDemo.1.0.exe"

        w_download wog "$URL" e61d8253b9fe0663cb3c69018bb3d2ec6152d488
    fi

    cd "$W_CACHE/$W_PACKAGE"
    w_ahk_do "
        run WorldOfGooDemo.1.0.exe
        winwait, World of Goo Setup, License Agreement
        u = $W_OPT_UNATTENDED
        if ( u > 0 ) {
            sleep 1000
            WinActivate
            send {Enter}
            winwait, World of Goo Setup, Choose Components
            send {Enter}
            winwait, World of Goo Setup, Choose Install Location
            send {Enter}
            winwait, World of Goo Setup, Thank you
            ControlClick, Make me dirty right now, World of Goo Setup, Thank you
            send {Enter}
        }
        winwaitclose, World of Goo Setup
        "
    w_declare_exe "$W_PROGRAMS_X86_WIN\\WorldOfGooDemo" WorldOfGoo.exe
}

#----------------------------------------------------------------

w_metadata  xvid dlls \
    title="Xvid Video Codec" \
    publisher="xvid.org" \
    year="2009" \
    media="download" \
    file1="Xvid-1.2.2-07062009.exe"

load_xvid()
{
    w_try w_call vcrun6
    w_download xvid http://www.koepi.info/Xvid-1.2.2-07062009.exe 435203e7f713c4484ca4f50f43e847f3dc118962
    w_try $WINE "$W_CACHE"/xvid/Xvid-1.2.2-07062009.exe $W_UNATTENDED_SLASH_SILENT
}

#----------------------------------------------------------------

#---- External Verbs ----
# This is experimental, just for testing; eventually we'll load from a particular directory

for verb in *.verb
do
    if grep -sqe '^w_metadata ' $verb && grep -sqe '^load_[a-z0-9_]\(\)' $verb
    then
        ( . ./$verb )
    fi
done

#----------------------------------------------------------------

#---- Main Program ----

# Do whatever the current menu says to the given app
# Unless you're in the run or uninstall menus, that means to install it.
wisotool_do_app()
{
    case $WISOTOOL_CURMENU in
    run)
        wisotool_run_app $W_PACKAGE
        ;;
    uninstall)
        wisotool_uninstall_app $W_PACKAGE
        ;;
    *) 
        wisotool_install_app $W_PACKAGE
        ;;
    esac
}

# Usage: set W_PACKAGE to name of command to execute, and $1 to full path if external verb
execute_command()
{
    # Load external verb
    case $W_PACKAGE in
    *.verb)
        case $1 in
        */*) . $1 ;;
        *) . ./$1 ;;
        esac
        W_PACKAGE="`echo $1 | sed 's,.*/,,;s,.verb,,'`"
        ;;
    esac

    case $W_PACKAGE in

    # FIXME: avoid duplicated code
    apps|benchmarks|dlls|fonts|games|run|uninstall|steam)
        WISOTOOL_CURMENU=$W_PACKAGE
        ;;

    # Late options
    -*)
        if ! wisotool_handle_option $W_PACKAGE
        then
            wisotool_usage 
            exit 1
        fi
        ;;

    # Hard-coded verbs
    list) wisotool_list_all ;;
    list-cached) wisotool_list_cached ;;
    list-download) wisotool_list_download ;;
    list-manual-download) wisotool_list_manual_download ;;
    list-installed) wisotool_list_installed ;;

    # load_ functions
    *)
        if wisotool_metadata_exists $W_PACKAGE
        then
            wisotool_do_app $W_PACKAGE
        else
            echo Unknown arg $W_PACKAGE
            wisotool_usage
            exit 1
        fi
        ;;
    esac
}

if ! test "$WISOTOOL_LIB"
then
    wisotool_detect_sudo

    # If user specifies menu on commandline, execute that command, but don't commit to commandline mode
    # FIXME: this code is duplicated several times; unify it
    if echo "$WISOTOOL_CATEGORIES" "$WISOTOOL_COMMANDMENUS" | grep -w "$1" > /dev/null
    then
        WISOTOOL_CURMENU=$1
        shift
    fi

    case "$1" in
    "")
        # GUI case
        # No non-option arguments given, so read them from GUI, and loop until user quits
        wisotool_detect_gui
        while true
        do
            case $WISOTOOL_CURMENU in
            main) verbs=`wisotool_mainmenu` ;;
            run) verbs=`wisotool_installed_menu` ;;
            uninstall) verbs=`wisotool_installed_menu` ;;
            *) verbs="`wisotool_showmenu`" ;;
            esac

            if test "$verbs" = ""
            then
                # "user didn't pick anything, just exit"
                break
            elif echo "$WISOTOOL_CATEGORIES" "$WISOTOOL_COMMANDMENUS" | grep -w "$verbs" > /dev/null
            then
                WISOTOOL_CURMENU=$verbs
            else
                # Otherwise user picked one or more real verbs.
                for W_PACKAGE in $verbs
                do
                    execute_command
                done
                break
            fi
        done
        ;;
    *)
        # Commandline case
        # User gave commandline arguments, so just run those verbs and exit
        for W_PACKAGE
        do
            execute_command $W_PACKAGE
        done
        ;;

    esac
fi
